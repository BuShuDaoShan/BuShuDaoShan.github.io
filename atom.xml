<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你好，这里是鹏鹏的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-03T14:59:51.774Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>pp_zZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>四.独立按键和矩阵键盘</title>
    <link href="http://example.com/2024/03/03/%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%E5%92%8C%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98/"/>
    <id>http://example.com/2024/03/03/%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%E5%92%8C%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98/</id>
    <published>2024-03-03T12:20:22.000Z</published>
    <updated>2024-03-03T14:59:51.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="独立按键和矩阵键盘"><a href="#独立按键和矩阵键盘" class="headerlink" title="独立按键和矩阵键盘"></a>独立按键和矩阵键盘</h1><h2 id="原理图："><a href="#原理图：" class="headerlink" title="原理图："></a>原理图：</h2><p><img src="/img/capture_20240303182545985.bmp" alt="capture_20240303182545985"></p><p>由原理图可以知道，独立按键和矩阵键盘有些线是接在一起的。</p><p>我们看到板子实物，会看到可更改的跳线帽。当2，3跳线帽接在一起时，启用的是独立按键。</p><h2 id="独立按键"><a href="#独立按键" class="headerlink" title="独立按键"></a>独立按键</h2><p>接下来我们简化独立按键原理图：</p><p><img src="/img/capture_20240303182953055.bmp" alt="capture_20240303182953055"></p><p>从上到下依次是S7、S6、S5、S4,所有按键可以同时输入与输出（区别于stm32)。</p><h4 id="输入读取"><a href="#输入读取" class="headerlink" title="输入读取"></a>输入读取</h4><p>按键按下为低电平，程序选择表达为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(s7 == 0)</span><br><span class="line">&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当按键没有按下时，为高电平。（此处涉及到单片机IO口的结构和电路分析基础，此处不做过多研究。PS：我也研究不明白。）</p><p>另外，单片机按键会出现抖动，这是由于单片机按键的机械原因，其按键具有弹性，断开与闭合时均会因为弹性作用，不会马上稳定的接通，最大抖动时常为（5-10ms)+(5-10ms)。</p><p>此外，单片机的输入高电平为5v，输出为0v，但输出的高低电平均为一个范围。</p><p><img src="/img/capture_20240303184405576.bmp" alt="capture_20240303184405576"></p><p>用示波器检测，我们即可发现其抖动的状态。</p><p>如果我们要消除抖动，在判断为按键按下时候加一个10ms的延时函数即可。</p><h4 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h4><p>定义端口;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sbit S7 = P3^0;</span><br><span class="line">sbit S6 = P3^1;</span><br><span class="line">sbit S5 = P3^2;</span><br><span class="line">sbit S4 = P3^3;</span><br></pre></td></tr></table></figure><p>定义函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void keyscan()//按键扫描函数</span><br><span class="line">&#123;   hc573(4);//开LED锁存器通道</span><br><span class="line">    if （S7 == 0）;</span><br><span class="line">    &#123;</span><br><span class="line">       P0 = 0xfe;//亮第一个灯</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;   </span><br><span class="line">   init();</span><br><span class="line">   while(1)</span><br><span class="line">   &#123;</span><br><span class="line">       keyscan();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得改跳线帽哦。</p><h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><p>1.按下S7亮灯，松开熄灭</p><pre><code>  void keyscan()//按键扫描函数&#123;       hc573(4);//开LED锁存器通道    if （S7 == 0）;    &#123;       P0 = 0xfe;//亮第一个灯       while(S7==0);//不松手的话就会一直卡在循环里，即一直亮第一个灯。       P0 = 0xff;    &#125; &#125;  </code></pre><p>2.按下S7，L1亮，再按下S7，L1灭</p><p>这里我们使用一个计分板：state</p><p>当state为0，led亮，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">uchar state;//keil5初始值默认为0</span><br><span class="line"></span><br><span class="line">void led()</span><br><span class="line">&#123;</span><br><span class="line">      hc573(4);</span><br><span class="line">      if(state == 0)//按第一次state为0，第二次为1</span><br><span class="line">      &#123;</span><br><span class="line">      P0 = 0xff;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">      P0 = 0xfe; </span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line">       </span><br><span class="line">void keyscan()//按键扫描函数</span><br><span class="line">   &#123;   </span><br><span class="line">    if (S7 == 0);</span><br><span class="line">      &#123;  </span><br><span class="line">        delay_ms(10);等待10ms再次确认</span><br><span class="line">        if (S7 == 0);//消抖</span><br><span class="line">        &#123;</span><br><span class="line">         state = 1 - state;</span><br><span class="line">         while(S7==0);</span><br><span class="line">         delay_ms(10);</span><br><span class="line">         while(S7==0);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">void main()</span><br><span class="line">&#123;   </span><br><span class="line">   init();</span><br><span class="line">   while(1)</span><br><span class="line">   &#123;</span><br><span class="line">       keyscan();</span><br><span class="line">       led();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.第一次按S7，L1亮，第二次按，L1以500ms闪烁，第三次熄灭。</p><p>整体思路不变，依然是用state，不过这次需要三个数，我们可以这样改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void keyscan()//按键扫描函数</span><br><span class="line">   &#123;   </span><br><span class="line">    if (S7 == 0);</span><br><span class="line">      &#123;   </span><br><span class="line">        if (S7 == 0);//消抖</span><br><span class="line">        &#123;</span><br><span class="line">         delay_ms(10);</span><br><span class="line">                                                            // state = 1 - state;</span><br><span class="line">        if (state == 0)</span><br><span class="line">        &#123;</span><br><span class="line">          state = 1; </span><br><span class="line">        &#125;</span><br><span class="line">        else if (state == 1)</span><br><span class="line">        &#123;</span><br><span class="line">        state = 2;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (state ==2)</span><br><span class="line">        &#123;</span><br><span class="line">        state = 0; </span><br><span class="line">        &#125;</span><br><span class="line">         while(S7==0);</span><br><span class="line">         delay_ms(10);</span><br><span class="line">         while(S7==0);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void keyscan()//按键扫描函数</span><br><span class="line"> &#123;   </span><br><span class="line">  if (S7 == 0);</span><br><span class="line">    &#123;    </span><br><span class="line">      delay_ms(10);</span><br><span class="line">      if (S7 == 0);//消抖</span><br><span class="line">      &#123;</span><br><span class="line">       state = 1 + state;</span><br><span class="line">       if(state == 3)//第四次state值为3，初始化为0继续循环</span><br><span class="line">          &#123;</span><br><span class="line">            state = 0;</span><br><span class="line">          &#125;</span><br><span class="line">       while(S7==0);</span><br><span class="line">       delay_ms(10);</span><br><span class="line">       while(S7==0);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;  </span><br></pre></td></tr></table></figure><p>两个改法核心思路都是：</p><p>第一次state值为0，执行亮L1操作，第二次按下state值为执行闪烁操作，第三次state为2，执行熄灭，第四次自动把state值改为0，再重新进入循环。</p><p>led部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void led()</span><br><span class="line">&#123;</span><br><span class="line">      hc573(4);</span><br><span class="line">      if(state == 0)</span><br><span class="line">      &#123;</span><br><span class="line">      P0 = 0xfe;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (state == 1)</span><br><span class="line">      &#123;      </span><br><span class="line">       P0 = 0xff;</span><br><span class="line">       delay_ms(500);</span><br><span class="line">       P0 = 0xfe;</span><br><span class="line">       delay_ms(500);       </span><br><span class="line">      &#125;</span><br><span class="line">      else if (state == 2)</span><br><span class="line">      &#123;</span><br><span class="line">        P0 = 0xff;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后我们写入单片机，我们发现，第三次无法实现。</p><p>这里，我们需要定时器中断</p><p>解释原因:</p><p>我们的程序执行过程是这样的：</p><p>1.keyscan</p><p>2.led</p><p>​       P0 = 0xff;<br>​       delay_ms(500);<br>​       P0 = 0xfe;<br>​       delay_ms(500);   //这个过程是每次执行完才去检测按键函数。</p><p>所以说，在这每次循环完闪烁之后，只有极短的时间去检测按键，但这个时间不足以让人的手去按下按键。</p><p>这样，我们的函数state==1就会一直循环下去。除非某次它刚好执行完，你刚好按下按键并且被它检测到，才会停止循环，执行state==2.</p><p>那怎么样才能加大我们被检测到的概率呢？</p><p>别忘了，delay_ms(500)函数是1ms的函数循环500次，只要我们把按键检测塞到这个循环里去，那我们被检测的概率将大大提高。</p><p>延时函数： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Delay_ms(uint xms)//@12MHz</span><br><span class="line">&#123;     </span><br><span class="line">     for (  ;  xms &gt; 0; xms--)</span><br><span class="line">   &#123;</span><br><span class="line">unsigned char i, j;</span><br><span class="line">i = 12;</span><br><span class="line">j = 169;</span><br><span class="line"> do</span><br><span class="line"> &#123;</span><br><span class="line">while (--j);</span><br><span class="line">  &#125; while (--i);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>不过，我们仅仅是在按键时候检测，所以不破坏原本延时函数，复制后改个名整个新的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Delay_msl(uint xms)</span><br><span class="line">&#123;     </span><br><span class="line">     for (  ;  xms &gt; 0; xms--)</span><br><span class="line">   &#123;</span><br><span class="line">unsigned char i, j;</span><br><span class="line">i = 12;</span><br><span class="line">j = 169;</span><br><span class="line"> do</span><br><span class="line"> &#123;  keyscan();//插入按键检测函数</span><br><span class="line">while (--j);</span><br><span class="line">  &#125; while (--i);</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>记得把keyscan放在新的延时函数之前。否则编译会出错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;独立按键和矩阵键盘&quot;&gt;&lt;a href=&quot;#独立按键和矩阵键盘&quot; class=&quot;headerlink&quot; title=&quot;独立按键和矩阵键盘&quot;&gt;&lt;/a&gt;独立按键和矩阵键盘&lt;/h1&gt;&lt;h2 id=&quot;原理图：&quot;&gt;&lt;a href=&quot;#原理图：&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="蓝桥杯" scheme="http://example.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>三.共阳数码管</title>
    <link href="http://example.com/2024/03/02/%E5%85%B1%E9%98%B3%E6%95%B0%E7%A0%81%E7%AE%A1/"/>
    <id>http://example.com/2024/03/02/%E5%85%B1%E9%98%B3%E6%95%B0%E7%A0%81%E7%AE%A1/</id>
    <published>2024-03-02T12:20:22.000Z</published>
    <updated>2024-03-03T14:59:58.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="共阳数码管"><a href="#共阳数码管" class="headerlink" title="共阳数码管"></a>共阳数码管</h2><p>数码管就是由LED组成的。<img src="/img/capture_20240229204119212.bmp" alt="capture_20240229204119212"></p><p>每个数码管的代号如图所示，按abcd顺时针走一圈即可。我们让P0=0x00就能点亮所有数码管（per)。</p><p>如果我们要让数码管成为一个2，那么就是</p><div class="table-container"><table><thead><tr><th>dp</th><th>g</th><th>f</th><th>e</th><th>d</th><th>c</th><th>b</th><th>a</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr></tbody></table></div><p>换算为十六进制就是<strong>（从右向左！！！！）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P0=0xa4;</span><br></pre></td></tr></table></figure><p>同理，0的话就是</p><div class="table-container"><table><thead><tr><th>dp</th><th>g</th><th>f</th><th>e</th><th>d</th><th>c</th><th>b</th><th>a</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><p>即:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P0=0xc0;</span><br></pre></td></tr></table></figure><p>不过听说比赛的时候赛点资源包里面是有数码管数字的十六进制的…..</p><p>接下来我们看原理图。</p><p><img src="/img/capture_20240229205434728.bmp" alt="capture_20240229205434728"></p><p>控制数码管，我们是由com公共端控制的，<img src="/img/capture_20240229205721961.bmp" alt="capture_20240229205434728"></p><p>abcd口由U7控制。端口连接情况如图所示，依然存在<strong>锁存器</strong>，依然存在<strong>或非门</strong>。</p><p>com连接情况也是显而易见。由U8控制。</p><p>不过需要注意的是，我们一共有8个数码管，每个阴极a和a，b和b都是接在一起的，如果我们需要显示0，那所有数码管都会只显示0。</p><p>因此，需要的线不是72个，而是16根线。具体如何操作我们后面再说。</p><h2 id="静态数码管"><a href="#静态数码管" class="headerlink" title="静态数码管"></a>静态数码管</h2><p>下面我们开始写代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#define uint unsigned int</span><br><span class="line">#define uchar unsignded char</span><br><span class="line">sbit LSA =P2^5;</span><br><span class="line">sbit LSB =P2^6;</span><br><span class="line">sbit LSC=P2^7;</span><br><span class="line">code uchaar segment[10] = (0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90);//把十个数码管的数字十六进制放进一个叫 segment的数组里去。code 意思就是我们以后不会再更改它了。</span><br></pre></td></tr></table></figure><p><img src="/img/capture_20240302100404991.bmp" alt="capture_20240302100404991"></p><p>当我们编译成功时，会看到下面状态栏里的内容<img src="/img/capture_20240302100821624.bmp" alt="capture_20240302100821624"></p><p>date是程序变量大小，xdate是外部存储器，code是存放了我们刚才的数组。</p><p>我们上一次学习了LED，蜂鸣器和继电器，每次我们都要重新定义<strong>573锁存器</strong>的输出，所以，我们写一个新的函数，用来调用我们需要的功能。</p><p>函数定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void hc573(unchar channel)</span><br><span class="line">&#123;</span><br><span class="line">    switch(channel)</span><br><span class="line">    &#123;</span><br><span class="line">      case 4:LSC = 1;LSB = 0; LEA = 0;break;</span><br><span class="line">      case 5:LSC = 1;LSB = 0; LEA = 1;break;//LED</span><br><span class="line">      case 6:LSC = 1;LSB = 1; LEA = 0;break;//数码管</span><br><span class="line">      case 7:LSC = 1;LSB = 0; LEA = 1;break;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void init ()</span><br><span class="line">&#123;</span><br><span class="line">   hc573(5);</span><br><span class="line">   P0 =Ox00;//控制第几个数码管量</span><br><span class="line">   hc573(4);</span><br><span class="line">   P0 = 0xff;//数码管显示8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义数码管函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void SMG(uchar seg)</span><br><span class="line">&#123;</span><br><span class="line">  hc573(6);  </span><br><span class="line">  P0 = 0xff;</span><br><span class="line">  hc573(7);</span><br><span class="line">  P0 = segment[seg];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> init();</span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">         SMG[7];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们的数码管就会全部显示数字7了。</p><h2 id="动态数码管"><a href="#动态数码管" class="headerlink" title="动态数码管"></a>动态数码管</h2><p>首先，我们的数码管是没法同时显示不同数字的。</p><p>那我们该怎么样才能让数码管同时显示不同数字呢？</p><p>我们没法改变数码管，但能用数码管欺骗我们的眼睛。</p><p>我们可以让第一个数码管显示1，然后熄灭其他数码管，再过1ms.让第二个数码管显示2，同时熄灭第一个和其他数码管，如此循环往复，就能欺骗我们的眼睛了。</p><p>这个效果叫做，<strong>余晖效应</strong>。</p><p>我们开始改代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void SMG(uchar pos,seg)</span><br><span class="line">&#123;</span><br><span class="line">  hc573(6);  </span><br><span class="line">  P0 = 0x01&lt;&lt; （pos-1）;//（数码管位选）让一个数码管亮，pos是1，第二个pos为2.</span><br><span class="line">  hc573(7);//数码管段选</span><br><span class="line">  P0 = segment[seg];</span><br><span class="line">  delay_ms(1);//记得在前面定义一个延时函数嗷</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义显示数字：20240302</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void display()</span><br><span class="line">&#123;</span><br><span class="line">   SMG(1,2);//第一位是位选，第二位是段选，这一行的意思是第一个数码管显示2</span><br><span class="line">   SMG(2,0);</span><br><span class="line">   SMG(3,2);</span><br><span class="line">   SMG(4,4);</span><br><span class="line">   SMG(5,0);</span><br><span class="line">   SMG(6,3);</span><br><span class="line">   SMG(7,0);</span><br><span class="line">   SMG(8,2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> init();</span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">         display();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就完成了。</p><p>不过，我们会发现，没有亮的地方有残影。</p><p>这里，我们就需要进行<strong>数码管消隐</strong>。</p><h2 id="数码管消隐"><a href="#数码管消隐" class="headerlink" title="数码管消隐"></a>数码管消隐</h2><p>出现的原因就是先进行位选，再进行段选，进行第二次循环的时候，上一次段选的状态会延续到我下一次位选。这样就会出现残影。</p><p>解决方法就是直接在每一次循环的时候，在位选前面加一次段选，令P0 = 0xff；</p><p>于是，我们进行消隐处理后的代码就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void SMG(uchar pos,seg)</span><br><span class="line">&#123;</span><br><span class="line">  hc573(7);         //消隐</span><br><span class="line">  P0 = 0xff;</span><br><span class="line">  hc573(6);         //数码管位选</span><br><span class="line">  P0 = 0x01&lt;&lt; （pos-1）;</span><br><span class="line">  hc573(7);         //数码管段选</span><br><span class="line">  P0 = segment[seg];</span><br><span class="line">  delay_ms(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数码管特殊字符"><a href="#数码管特殊字符" class="headerlink" title="数码管特殊字符"></a>数码管特殊字符</h2><h4 id="字母"><a href="#字母" class="headerlink" title="字母"></a>字母</h4><p>字母的话我们和数字方法一样，这里不过多赘述。</p><p>当我们需要调用的时候，记得在我们放入字母的segment数组中进行调用。</p><p>我们的数码管显示函数是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void display()</span><br><span class="line">&#123;</span><br><span class="line">   SMG(1,2);</span><br><span class="line">   SMG(2,0);</span><br><span class="line">   SMG(3,2);</span><br><span class="line">   SMG(4,4);</span><br><span class="line">   SMG(5,0);</span><br><span class="line">   SMG(6,11);//后三个数码管就会显示我们已经编辑好的字符。</span><br><span class="line">   SMG(7,12);</span><br><span class="line">   SMG(8,13);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小数点"><a href="#小数点" class="headerlink" title="小数点"></a>小数点</h4><p>如果是显示小数点的话，那我们让dp输出为0就好了，这样的话我的数字要全部重新写。当然我们还有更加便捷的方法。</p><p>我们先举个<strong>狸子</strong>：</p><p>如果是显示数字1</p><p>11111001</p><p>变为</p><p>01111001</p><p>这里改变的只有最后一位，所以我们的思路就是保留前七位，更改最后一位。</p><p>这里我们使用&amp;运算符。</p><p>&amp;和1效果为保留，&amp;0效果就是清除。</p><p>所以，我们搞出来一个</p><p>01111111就可以把最后一位的dp位置清除为0.</p><p>所以，我们的代码更改为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void SMG(uchar pos,seg)</span><br><span class="line">&#123;</span><br><span class="line">  hc573(7);        </span><br><span class="line">  P0 = 0xff;</span><br><span class="line">  hc573(6);         </span><br><span class="line">  P0 = 0x01 &lt;&lt; （pos-1）;</span><br><span class="line">  hc573(7);        </span><br><span class="line">  P0 = segment[seg];</span><br><span class="line">  delay_ms(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SMG1(uchar pos,seg)//让每一数字显示小数点</span><br><span class="line">&#123;</span><br><span class="line">  hc573(7);         </span><br><span class="line">  P0 = 0xff;</span><br><span class="line">  hc573(6);        </span><br><span class="line">  P0 = 0x01 &lt;&lt; （pos-1）;</span><br><span class="line">  hc573(7);        </span><br><span class="line">  P0 = segment[seg]&amp;0x7f;//清除最后一位</span><br><span class="line">  delay_ms(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示函数更改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void display()</span><br><span class="line">&#123;</span><br><span class="line">   SMG(1,2);</span><br><span class="line">   SMG(2,0);</span><br><span class="line">   SMG(3,2);</span><br><span class="line">   SMG(4,4);</span><br><span class="line">   SMG(5,0);</span><br><span class="line">   SMG1(6,11);//这样就好了。</span><br><span class="line">   SMG1(7,12);</span><br><span class="line">   SMG1(8,13);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;共阳数码管&quot;&gt;&lt;a href=&quot;#共阳数码管&quot; class=&quot;headerlink&quot; title=&quot;共阳数码管&quot;&gt;&lt;/a&gt;共阳数码管&lt;/h2&gt;&lt;p&gt;数码管就是由LED组成的。&lt;img src=&quot;/img/capture_20240229204119212.bmp&quot;</summary>
      
    
    
    
    <category term="蓝桥杯" scheme="http://example.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>二.继电器和蜂鸣器</title>
    <link href="http://example.com/2024/02/29/%E8%9C%82%E9%B8%A3%E5%99%A8%E5%92%8C%E7%BB%A7%E7%94%B5%E5%99%A8/"/>
    <id>http://example.com/2024/02/29/%E8%9C%82%E9%B8%A3%E5%99%A8%E5%92%8C%E7%BB%A7%E7%94%B5%E5%99%A8/</id>
    <published>2024-02-29T13:45:32.000Z</published>
    <updated>2024-03-03T14:54:17.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="蜂鸣器和继电器"><a href="#蜂鸣器和继电器" class="headerlink" title="蜂鸣器和继电器"></a>蜂鸣器和继电器</h2><h4 id="继电器"><a href="#继电器" class="headerlink" title="继电器"></a>继电器</h4><p>原理图：</p><p><img src="/img/屏幕截图 2024-03-02 000621.png" alt="屏幕截图 2024-02-29 195227"></p><p>原理：通电导线产生磁场，把K1吸下来。</p><p>可以理解为单刀双掷开关。K1控制m1和m2。</p><p>只要让N RELAY低电平即可。</p><p>这个二极管的作用大概是当断电的时候，保护电路？</p><h4 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h4><p><img src="/img/capture_20240229195647734.bmp" alt="capture_20240229195647734"></p><p>让蜂鸣器工作的话只要在N BUZZ接入低电平即可。</p><p>然后我们在原理图上找这两个口。</p><p><img src="/img/capture_20240229200511192.bmp" alt="capture_20240229200511192"></p><p>ULN2003是双极型线性集成电路。</p><p>内部原理就是一个非门。</p><p>输入高输出低，输入低输出高。如果用它来控制电机，那么只能实现单方向的控制。</p><p>左边还是一个锁存器。</p><p>于是通路就是：</p><p>N RELAY—-P04—-Y5C</p><p>Y5C和一个或非门连在一起，由Y5控制</p><p><img src="/img/capture_20240229201850805.bmp" alt="capture_20240229201850805"></p><p>Y5的尽头是一个译码器，我们之前说过了。</p><p><img src="/img/capture_20240229201842286.bmp" alt="capture_20240229201842286"></p><p>所以，最终我们让这三个口从下到上依次取值101，Y5最终就会输出一个低电平，Y5C就是高电平。</p><p>最后，我们让P00-P07取值为00001000，换算为十六进制为10</p><p>即:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P0 = 0x10;</span><br></pre></td></tr></table></figure><p>同理，我们让继电器打开的话，P0-P7取值为01000000，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P0 = 0x40;</span><br></pre></td></tr></table></figure><p>都打开的话就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P0=0x50;</span><br></pre></td></tr></table></figure><p>都关闭的话就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P0=0x00;</span><br></pre></td></tr></table></figure><p>最后注意LED和继电器的初始化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;蜂鸣器和继电器&quot;&gt;&lt;a href=&quot;#蜂鸣器和继电器&quot; class=&quot;headerlink&quot; title=&quot;蜂鸣器和继电器&quot;&gt;&lt;/a&gt;蜂鸣器和继电器&lt;/h2&gt;&lt;h4 id=&quot;继电器&quot;&gt;&lt;a href=&quot;#继电器&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="蓝桥杯" scheme="http://example.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>一.LED的点亮</title>
    <link href="http://example.com/2024/02/28/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    <id>http://example.com/2024/02/28/%E8%93%9D%E6%A1%A5%E6%9D%AF/</id>
    <published>2024-02-28T15:39:22.000Z</published>
    <updated>2024-03-03T14:54:04.277Z</updated>
    
    <content type="html"><![CDATA[<p>蓝桥杯</p><p>一.LED以及锁存器的跟随模式，io模式vcc或非门，keil新建项目文件以及第一个程序</p><p><img src="/img/capture_20240228192033725.bmp" alt="capture_20240228192033725"></p><p>led有八个灯珠，右边vcc为正极供电，因此，只需要控制左边负极为低电平，即可控制led。</p><p>但是在led左边有一个M74hc573锁存器。</p><p>简单来说，就是由输入引脚D1-D8，来控制输出引脚Q1-Q8，OE和LE的取值会影响输入数据控制输出数据。</p><p>当OE为L（低电平0v）时，LE为高电平H，为跟随模式，即输出数据=输入数据。</p><p>OE为L时，LE为低电平L时，为锁存模式，即输出数据=上一个时刻的输入数据。</p><p>我们这个锁存器的OE已经接了地，也就是说已经接了低电平，那我们只需要控制LE为高电平即可。</p><p>但是，这里LE接了一个”Y4C”，我们使用全局搜素，在原理图下面找到了另一个Y4C.<img src="/img/capture_20240228192602249.bmp" alt="capture_20240228192602249"></p><p>这是一个或非门，蓝桥杯比赛中，WR和GND是接在一起的，也就是说，WR固定为0，如果Y4(12)为0，Y4C则输出高电平，反之则低电平。<img src="/img/capture_20240228194518765.bmp" alt="capture_20240228194518765"></p><p>74HC02的Y4口又和U24接在一起，这个东西叫做74HC138译码器，</p><p>左边从上到下，如果为000，换为二进制则Y0口输出为低电平，Y1-Y7为高电平。</p><p>001，Y1口0其余1。</p><p>010，Y2口0其余1</p><p>011，Y3口0其余1….</p><p>100，Y4口0其余1</p><p>新建项目文件：：</p><p>代码开始：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">sbit LSA =P2^5;</span><br><span class="line">sbit LSB =P2^6;</span><br><span class="line">sbit LSC=P2^7;</span><br><span class="line">sbit L1 = P0^0;</span><br><span class="line">sbit L2 = P0^1;</span><br><span class="line">sbit L3 = P0^2;</span><br><span class="line">sbit L4 = P0^3;</span><br><span class="line">sbit L5 = P0^4;</span><br><span class="line">sbit L6 = P0^5;</span><br><span class="line">sbit L7 = P0^6;</span><br><span class="line">sbit L8 = P0^7;</span><br><span class="line">void init()//不过，我们的蜂鸣器会乱响，这里我们加入一点东西（我看不懂思密达，反正就是加了）</span><br><span class="line">&#123;</span><br><span class="line">LSC=1;LSB =0;LSA=1;</span><br><span class="line">P0=0x00;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;        init()//这一行也是加的</span><br><span class="line">​        LSC=LSA=LSB;</span><br><span class="line">​        L1=0;</span><br><span class="line">​        L2=L3=L4=L5=L6=L7=L8=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LSAbc为锁存器部分，P0为LED部分，另外一定要在程序里加上while，确保单片机的程序可以重复运行。</p><h4 id="延时函数"><a href="#延时函数" class="headerlink" title="延时函数:"></a>延时函数:</h4><p>在isp烧录软件里找到延时函数，选择12mhz，定时长度为1s</p><p><img src="/img/capture_20240228201640366.bmp" alt="capture_20240228201640366"></p><p>先把整个复制下来，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">()</span><span class="comment">//@12MHz</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line">i = <span class="number">12</span>;</span><br><span class="line">j = <span class="number">169</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此之前，为了方便起见，宏定义两个快捷操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uchar unsignded char</span></span><br></pre></td></tr></table></figure><p>把延时函数变量改为 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Delay_ms(uint xms)</span><br></pre></td></tr></table></figure><p>我们希望它延时多少毫秒，就把它循环几次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (  ;  xms &gt; 0; xms--)</span><br></pre></td></tr></table></figure><p>于是，延时函数就变成了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(uint xms)</span><span class="comment">//@12MHz</span></span><br><span class="line">&#123;     </span><br><span class="line">     <span class="keyword">for</span> (  ;  xms &gt; <span class="number">0</span>; xms--)</span><br><span class="line">​      &#123;</span><br><span class="line">​<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line">​i = <span class="number">12</span>;</span><br><span class="line">​j = <span class="number">169</span>;</span><br><span class="line">​ <span class="keyword">do</span></span><br><span class="line">​ &#123;</span><br><span class="line">​<span class="keyword">while</span> (--j);</span><br><span class="line">​  &#125; <span class="keyword">while</span> (--i);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里的部分我们放到所以sbit下面，作为自定义函数。</p><p>如果在程序内需要引用，这样使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delay_ms(500);//将延时函数循环执行500次，即延时500ms</span><br></pre></td></tr></table></figure><p>于是，我们的主函数就变成了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;      init()</span><br><span class="line">       LSC=LSA=LSB;</span><br><span class="line">       L1= L2=L3=L4=L5=L6=L7=L8=<span class="number">1</span>;<span class="comment">//熄灭</span></span><br><span class="line">       delay_ms(<span class="number">500</span>)</span><br><span class="line">       L1= L2=L3=L4=L5=L6=L7=L8=<span class="number">0</span>;<span class="comment">//点亮</span></span><br><span class="line">       delay_ms(<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>每次都要把L1到L8都写一遍。是不是这样写太麻烦了？还有一个更简单的写法。</p><h2 id="把L1到L8对应的数字改写成16进制，"><a href="#把L1到L8对应的数字改写成16进制，" class="headerlink" title="把L1到L8对应的数字改写成16进制，"></a>把L1到L8对应的数字改写成16进制，</h2><p>主函数部分更改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">P0=0x00;</span><br><span class="line">delay_ms(500);</span><br><span class="line">P0=0xff;</span><br><span class="line">delay_ms(500);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外需要注意的一点是，每次LED的初始状态需要为<strong>熄灭状态</strong>。</p><p>所以我们这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void init()//init函数为初始化LED</span><br><span class="line">&#123;</span><br><span class="line">LSC=1;LSB =0;LSA=1;</span><br><span class="line">P0=0x00;//防止蜂鸣器和继电器乱响</span><br><span class="line">LSC=1;LSB=0;LSB=0;</span><br><span class="line">P0=0xff;//LED初始化为熄灭状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：我后续写程序的思路是模块化编程，每个功能尽量使用一个函数来实现。 </p><p>例如：刚刚写的LED程序，改成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void led()</span><br><span class="line">&#123;</span><br><span class="line">P0=0x00;</span><br><span class="line">delay_ms(500);</span><br><span class="line">P0=0xff;</span><br><span class="line">delay_ms(500);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们的主函数就变为了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    init();//初始化</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    led();//调用led函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>通过<strong>取反操作符</strong>，我们还能简化led的程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void led()</span><br><span class="line">&#123;</span><br><span class="line">P0 =~P0;</span><br><span class="line">delay_ms(500);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以这么做的原因的我们在init()中已经把P0全部熄灭了，在led的程序中我们使用取反操作符就刚好能把0x00全部取反为0xff,也就是把熄灭变为点亮。</p><h2 id="流水灯"><a href="#流水灯" class="headerlink" title="流水灯"></a>流水灯</h2><p>讲完上面最麻烦的方法，逐一定义每个灯可以实现，不过，我们有运算符，那么，我们流水灯的代码也就不复杂了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   void main()</span><br><span class="line">&#123;</span><br><span class="line">    init();//初始化</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">   P0 = P0 &lt;&lt; 1;//这里也可以更改为我们定义好的led函数，写法是一样的</span><br><span class="line">   delay_ms(500)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，程序的循环体每次执行一次，我们的P0的值就会从11111变为01111，00111，00011…..从而达到流水灯的效果。</p><p>PS：从左到右</p><h6 id="十分简洁。"><a href="#十分简洁。" class="headerlink" title="十分简洁。"></a>十分简洁。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;蓝桥杯&lt;/p&gt;
&lt;p&gt;一.LED以及锁存器的跟随模式，io模式vcc或非门，keil新建项目文件以及第一个程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/capture_20240228192033725.bmp&quot; alt=&quot;capture_202402281920337</summary>
      
    
    
    
    <category term="蓝桥杯" scheme="http://example.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>你好，佳佳</title>
    <link href="http://example.com/2024/02/07/cs2/"/>
    <id>http://example.com/2024/02/07/cs2/</id>
    <published>2024-02-07T11:39:43.000Z</published>
    <updated>2024-02-28T15:02:33.824Z</updated>
    
    <content type="html"><![CDATA[<p>昨天晚上，我做了一个梦。睡眠不好的时候我才会做梦。</p><p>可是，昨天的我回到家，明明那么累，却还是做了一个梦。</p><p>说它是梦都会显得它很长了。</p><p>我梦到，我抢到佳佳子的签售票了。</p><p>梦的全部，就只是我拿出手机，看见在“我的购票”那一栏，出现了我买到的佳佳的签售票。</p><p>就只是这么简单的一个动作，我还要做个梦。听起来很好笑对吧。我也觉得好笑。</p><p>小时候也会做这样的梦：想买一个很想要的玩具，可恶的爸妈就是不买。我哭哭啼啼地离开玩具店，回家躺在床上就会梦到我拥有了这个玩具。</p><p>在梦里，我把硬纸的背板从吸塑上扯下，玩具从吸塑里掉到床上，我拿着它和老伙计汇合，看看你的胳膊能不能给他装上，你的武器能不能借我用用。</p><p>我可从不管这些梦里的玩具是什么来路，也许是爸爸进城里给我的惊喜，亦或是爷爷许久未来看他孙子时候路上买的最贵的玩具。</p><p>总之，我喜欢梦里拥有玩具的感觉。这样的梦经历了几次之后，我就明白这是梦了。</p><p>后来，我还是会在梦里拥有我想要的玩具，即便我知道那是梦，我也会竭尽所能地不去醒来。但是，我还是发现了一件令我害怕的事。如果在梦里，我极力地把玩具的细节描绘清楚，我就会不可避免的醒来。并且这种行为和具有故事属性的梦境不同，没有故事发展的梦，是无法在醒来后迅速睡着衔接起来。</p><p>从这之后，不知道为什么，这样的梦就越来越少了。</p><p>也可以说，我的梦越来越少了。</p><p>但是我的白日梦却越来越多。</p><p>我会在写奥数作业的时候幻想，也许我这一次吃好多德克士的炸鸡之后脑子就会解开所有奥数题。</p><p>我会在阳光照到她头发上时幻想，也许今天结束晚自习后，她会把我拉到教室后面小声告诉我其实她也喜欢我。</p><p>我会在对完模考题的答案之后幻想，也行试卷上的答案是错的，碰巧我涂在答题卡上的才是正确答案。</p><p>我会在开学第一天分班的时候幻想，也许新班级的花名册上也有你的名字。也许你会和我分到一个小组。</p><p>我会在高考对完答案后幻想，也许这份答案有问题呢，也许高考批阅人那里的答案和我是一样的。</p><p>我会在填完志愿后幻想，也许这个学校会被我捡漏，也许我刚好是压着它的分数线被录取的。也许我录取到的学校刚好也录取了你。</p><p>我会在学那些晦涩的专业课的时候幻想，也许我是这个专业的天才呢，也许我稍微认真一点就能比肩那些在比赛里意气风发的学长。</p><p>我会在街上戴耳机信步的时候幻想，也许下一个街角我就会撞见要回家的你。</p><p>你看着我，好像有话要说<br>。<br>不过，我不会让你说的。</p><p>如果梦的细节太清楚，我迟早会醒来。</p><p>所以，我就当真的碰见了你。真的你也不知道我碰见了当真的你。</p><p>我这样想着，也就没那么难过了，反正我迟早会见到佳佳。不管是抖音里还是微博里，不管是现实里还是梦里。</p><p>然后我就高兴起来啦，因为我也迟早会再次见到你。也许是在别人的朋友圈，也许在是同学聚会 也许是在你的婚礼，也许是在照片里，也许在是回忆里，亦或是在我看不懂的梦里。</p><p>某个我不知道的地方，肯定有一堆人在评选全世界最能做梦的人。我想，我一定在候选人的名单里。</p><p>我正准备睡觉，突然这样幻想起来。</p><p>不过奇怪的是，我没有直接梦见佳佳，而是梦见了我有了她的签售票。就像我很少梦见你，却经常梦见你给我发来的消息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天晚上，我做了一个梦。睡眠不好的时候我才会做梦。&lt;/p&gt;
&lt;p&gt;可是，昨天的我回到家，明明那么累，却还是做了一个梦。&lt;/p&gt;
&lt;p&gt;说它是梦都会显得它很长了。&lt;/p&gt;
&lt;p&gt;我梦到，我抢到佳佳子的签售票了。&lt;/p&gt;
&lt;p&gt;梦的全部，就只是我拿出手机，看见在“我的购票”那一</summary>
      
    
    
    
    <category term="有话" scheme="http://example.com/categories/%E6%9C%89%E8%AF%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>故事很短，你随便看看</title>
    <link href="http://example.com/2023/08/13/cs1/"/>
    <id>http://example.com/2023/08/13/cs1/</id>
    <published>2023-08-13T15:39:22.000Z</published>
    <updated>2024-02-28T15:02:26.582Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个很短的故事。</p><p>想起三年前刚开学，有个特别特别好看的姑娘和我一个小组。<br>我们这里最小单位就是五人小组，没有同桌。<br>她特别单纯，还和我小学是一个辅导班。<br>她记得我，不过我并不记得她。<br>这开局直接就是天选。但是我一手好牌打得稀烂。<br>和那些稍微会一点小心思的男生比起来我就是弱鸡。<br>啥也不懂，啥也不明白，最后还被她感觉烦了。<br>暗自神伤地喜欢了她一年。<br>现在想起来我就是纯纯大舔狗，还是那种人家不要还硬凑的感觉。<br>高一结束就分班了。<br>看完分班结果真的就是天塌下来的感觉。<br>很遗憾没和她一个班。<br>她留在了普通班，我去了稍微好一点的班。<br>我想过她会和谁在一起，但是没人想过她，会和高一新来的小男生在一起。<br>这件事让全年级的人大跌眼镜。<br>没错，就是全年级。<br>毕竟她是年级的大美女，我们都以为最后她会和那种学习又好人也好的男生在一起。<br>我们都自己说，高一就高一吧，毕竟人如果不错的话我们也不会乱说话<br>不过在一起了两个月她们就分手了。<br>听闻高一的风言风语，这小男生嫖过。<br>这件事对于我们年级来说都大为震撼 毕竟我的高中还是相当不错的，没有那些社会学生。<br>后来我问她 你这什么眼光，她说 她应该没有嫖过，但恐怕或多或少肯定沾染过，毕竟没有空穴来风的事情。<br>后来小男生在宿舍聚众抽烟被停课三个月。<br>不过整个高二我的心神已经被搅乱了。<br>现在想想，那段时间我真的和傻了一样。还跑到楼下喊“刘xx,U are the apple of my eye!”</p><p>是一本书封面的句子，也是一部电影里出现过的画面。</p><p>那部电影和小说同名，叫《那些年，我们一起追的女孩》<br>所以结果显而易见，即便后来高三发奋，依然只能上个普通的一本学校。虽然也能去很多偏远的211，不过最后这毕竟不是好结果。<br>后来她依然很美，朋友圈依然不乏刷屏的评论，一如既往。</p><p>她现在也早就有了男朋友，是西电的。不是我这个西邮比得了的。</p><p>但我老是觉得她好像没以前好看了。<br>她仍然是美女，不过少了一点神韵。<br>一点我喜欢她的时候的神韵。<br>她最好的样子好像也一去不复返了。<br>可能吧，也许只有我这么想。<br>也许回不去的是曾经喜欢她的我呢。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一个很短的故事。&lt;/p&gt;
&lt;p&gt;想起三年前刚开学，有个特别特别好看的姑娘和我一个小组。&lt;br&gt;我们这里最小单位就是五人小组，没有同桌。&lt;br&gt;她特别单纯，还和我小学是一个辅导班。&lt;br&gt;她记得我，不过我并不记得她。&lt;br&gt;这开局直接就是天选。但是我一手好牌打得稀烂。&lt;b</summary>
      
    
    
    
    <category term="有话" scheme="http://example.com/categories/%E6%9C%89%E8%AF%9D/"/>
    
    
  </entry>
  
</feed>
