<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你好，这里是鹏鹏的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-05-14T17:23:35.065Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>pp_zZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我有一个只出现在白日闲暇时的美丽幻梦</title>
    <link href="http://example.com/2024/05/15/%E6%88%91%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E5%9C%A8%E7%99%BD%E6%97%A5%E9%97%B2%E6%9A%87%E6%97%B6%E7%9A%84%E7%BE%8E%E4%B8%BD%E5%B9%BB%E6%A2%A6/"/>
    <id>http://example.com/2024/05/15/%E6%88%91%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E5%9C%A8%E7%99%BD%E6%97%A5%E9%97%B2%E6%9A%87%E6%97%B6%E7%9A%84%E7%BE%8E%E4%B8%BD%E5%B9%BB%E6%A2%A6/</id>
    <published>2024-05-14T16:24:45.000Z</published>
    <updated>2024-05-14T17:23:35.065Z</updated>
    
    <content type="html"><![CDATA[<p>【1】</p><p>最近我听了很多的歌。</p><p>汪峰的《光明》《生来彷徨》《在雨中》、陶喆的《天天》《小镇姑娘》《流沙》·····</p><p>多吗？</p><p>不多。当然，我这里指的是听了一遍会单曲循环的歌。对我这个老是抱着听过的歌天天听的人来讲确实算是多的了。以至于单曲循环这几天晚上睡觉时，脑子里面都是：</p><p>“我想要天天说   天天说   天天对你说我有多爱你”“不明白  不明白  为什么我不能放得开”。</p><p>好像没什么奇怪的。不就是歌听多了，“余音绕梁”了嘛。</p><p>可是，我总感觉有点淡淡的忧伤。</p><p>这种感觉像什么呢？</p><p>像彼时的我在宿舍的床上敲着这些字，宿舍里面的空调让我有发冷。</p><p>临近十一点从诺大的实验室走到诺大的深夜操场的寒意。</p><p>自习分析电路毫无头绪的困窘。</p><p>脑袋里空响的寂寥。</p><p>是深夜的孤独袭来？还是自我某时期的莫名空虚？</p><p>我不知道。</p><p>不过比起夜晚的胡思乱想，白日的美丽幻梦更令我着迷。</p><p>不知道多少次在高数讲定义时走神，在大物讲解例题时出游，在电路条件拆解时深潜····我在找某个东西，某个我不曾得到，但距离我很近的东西。</p><p>它会在我集中精力的时候闯进我的脑袋里来，搅乱我思考的一切。我思绪被迫打断。</p><p>看着它狡黠的眼神，我告诉自己，我一定要抓住它。</p><p>可是这样往往是徒劳的。因为我当我追上它的步伐时，我就会被自己拉回去。</p><p>我告诉自己，“拜托，你在听课啊！”，我只能回过头来，回到我的世界去。</p><p>可是，在我的世界里的老师已经讲了很久了，我被他们卡在中间，继续神游也不是，继续听课也不是······我被扰乱了。</p><p>它是什么呢。</p><p>我百思不得其解。</p><p>我沉溺其中。</p><p>【2】</p><p>你拍了拍我，别难过，一切都会好的。</p><p>我很疑惑，我干嘛啦。我只是在重复每天的事情而已，我难过什么啦？</p><p>可是你就是很难过，总之你没有以前快乐了。</p><p>那是当然的啊，要学的东西那么多，还有那么多不会的·······我当然不开心啊。</p><p>不是，你不是因为这些事。</p><p>那是什么呢？</p><p>是我早就规避掉的吗。</p><p>【3】</p><p>学校有草坪音乐节，我刚好路过。</p><p>可我要上晚自习。</p><p>妈的，晚自习翘了不就好了。你的诗意大学呢?你的自由意志呢？你的美的熏陶呢？</p><p>可我知道的。</p><p>我在高中的时候幻想过，在毕业晚会那天给喜欢的女孩弹吉他唱歌。</p><p>可我直到现在也没学会吉他。</p><p>我也不喜欢那个女孩了。</p><p>我不会爱，我也不会再爱了。</p><p>我不敢爱。</p><p>于是，那个只出现在白日闲暇时的美丽幻梦又出现了。</p><p><img src="https://pic.imgdb.cn/item/66439a170ea9cb140379ac6e.jpg" alt="$(Z7~JOE][TU[KC%_UE`F[3.jpg"></p><p><img src="https://pic.imgdb.cn/item/66439a0a0ea9cb14037998ea.jpg" alt="L9`{UYUMT7Z~]354SGE5I_D.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">我 12:07</span><br><span class="line">因为我爱她，所以我不想让她走</span><br><span class="line">可是正是因为我爱她，所以又应该让她去追梦</span><br><span class="line">[流泪][流泪]</span><br><span class="line">高数线代有些题无解就是答案</span><br><span class="line">可现实里的无解是什么呢</span><br><span class="line"></span><br><span class="line">萌 12:50</span><br><span class="line">我贼</span><br><span class="line">无解就无解换道题做</span><br><span class="line"></span><br><span class="line">我 13:00</span><br><span class="line">可是做题之前</span><br><span class="line">我怎么会知道它会是无解</span><br><span class="line">所以这就是人生</span><br><span class="line">处处不确定的才是人生</span><br><span class="line"></span><br><span class="line">萌 13:09</span><br><span class="line">好呀</span><br><span class="line">静待花开就好了</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;【1】&lt;/p&gt;
&lt;p&gt;最近我听了很多的歌。&lt;/p&gt;
&lt;p&gt;汪峰的《光明》《生来彷徨》《在雨中》、陶喆的《天天》《小镇姑娘》《流沙》·····&lt;/p&gt;
&lt;p&gt;多吗？&lt;/p&gt;
&lt;p&gt;不多。当然，我这里指的是听了一遍会单曲循环的歌。对我这个老是抱着听过的歌天天听的人来讲确实算是多</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>武汉</title>
    <link href="http://example.com/2024/05/06/%E6%AD%A6%E6%B1%89/"/>
    <id>http://example.com/2024/05/06/%E6%AD%A6%E6%B1%89/</id>
    <published>2024-05-05T16:14:15.000Z</published>
    <updated>2024-05-05T16:26:49.539Z</updated>
    
    <content type="html"><![CDATA[<p>2024/5/4[18:28:18]<br>此刻，我坐在回西安的高铁上。旁边的之已经睡着了，同车厢的杰也大概在睡觉。</p><p>耳机里是汪峰的《光明》。</p><p>昨晚同萌和贤道了别，今早又同威说了再见。网络确实是拉进了大家的距离。不管天南海北，敲敲手机就能把我的文字和语音发给朋友们，这总算是科技的进步。</p><p>在辛亥革命纪念馆纪念品商店看到了有在出售辛亥革命的纪念邮票。我觉得邮票好常见，但是细细想来，我居然没有寄过信。</p><p>我望着那些邮票出了神。</p><p>我唯一一次寄信，是给一个杂志社。</p><p>那封信里表达了我对其社的热爱，不过具体是什么杂志，我又忘记了。</p><p>与其说是寄信，其实到头来也没有寄出去。最后那封信被留在了某一本杂志里，被时间冲没，不知所踪。</p><p>后来，我也写过好多明信片给同学当做生日的贺卡。虽然内容都是信的格式，不过几乎都是当面赠予，没有寄信的仪式感。</p><p>我拿起那些邮票，细细端详，一共有七八种板式，我最中意的是一张辛亥革命主要人物的一版邮票。有十二位前辈，我在历史书上大都听过他们的名字。</p><p>我总觉得既然来了武汉，要带走点什么，也要留下点什么。</p><p>我好想买下它，可是几近一百元的价格和捉襟的生活费，又让我望而却步。</p><p>最终还是还是没有狠下心。</p><p>不过我和朋友们一起拍了很多的照片。</p><p>带走这些，也足够留作纪念了。</p><p>要说留下什么，在我身边酣睡的之之最有话语权。</p><p>因为他昨天丢失了他的身份证。用他的话来讲，武汉留下了他的身份证当做纪念。</p><p>我留下了什么呢？</p><p>我思考良久。</p><p>[19:01:27]</p><p>我在整理这一次出行的相册。</p><p>相较于天津，照片少了很多。我想原因大概是假期武汉出游的人很多，很多景区人头攒动，没有拍照的欲望，即便拍到了景色，多是边角充斥着各色各样的人的照片，不加以裁切难以留存。<br>这些照片里，大部分是景色。剩下的几乎都是朋友的照片。</p><p>当然，除了那几张要路人拍的合影，其他都是不正经的照片。</p><p>[20:28:32]</p><p>虽然佳佳的漫展在沈阳和杭州，可我最后还是选了武汉。</p><p>本来我非常笃定我这次一定会去杭州看佳佳。因为我将其定义为看完的释怀。</p><p>现在我已经快要到西安北站了。很有趣的是，在离开武汉后，我想我不再需要佳佳了。</p><p>曾经的我需要佳佳吗？</p><p>不知道。我肯定的是我很喜欢佳佳。</p><p>因为佳佳需要钱，才出演了一个名叫《完蛋，我被美女包围了》的游戏里的角色。</p><p>她叫肖鹿。</p><p>是吧。以前佳佳需要肖鹿。</p><p>因为肖鹿，佳佳现在才不用像以前那样非常努力地赚钱。以后她也不用看着甲方脸色啦，片场也有盒饭啦，直播也有好</p><p>多好多人看啦，听去杭州的佳人们讲，漫展有一半的人都是来看佳佳的。</p><p>我一直以为佳佳是我的精神支柱的。</p><p>可直到我选择去武汉，而不是杭州或者沈阳见佳佳时候，我才明白，我的精神支柱永远是我身边的人。</p><p>我一直喜欢邹佳佳，但我不再需要佳佳了。</p><p>2024/5/5 23：57</p><p>我晓得了。</p><p>我把理想留在了那里。</p><p>如果我去的不是武汉，是北京、杭州、上海，也许我的想法没有那么笃定。</p><p>可恰恰是武汉，经历了“武大那么大”的冲击，随之而来的武理显得那么平和。</p><p>所以，我十分想去武汉理工大学读书。</p><p>我该去考研。</p><p>我总是有大梦，梦的内容也没那么不切实际，可在我身上就是白日梦。多小的梦都是白日梦。我的梦从来没有成真过。</p><p>我突然好厌烦高考前一百天的我。偏偏是该奋斗的时候选择了安逸。沉溺在大家很努力我也很努力的假象谎言里，匆匆忙忙不明不白地结束了高考。家人长吁短叹，最后也是勉强接受了这样的结果。谁能想象四天前我对自己的学校还算满意这样的事情居然是事实。</p><p>不过此刻我已经释怀，释怀过去的我的幼稚和懒散。同时我也艳羡，艳羡朋友的大学的姿态，其早已超出我的曾经理解范畴。</p><p>我回首放假前的几节课，发觉我居然已经无端浪费了那么多时间。我讲放假前没办法听课，可确确实实是自我控制力太差。令人讨厌的大物老师在下课前几分钟总会讲这时能专注看课本的人才是真正自律的人。虽然他十分讨厌，但我十分认可他的话。</p><p>此时我在写这篇文章，我很笃定，我晓得我明天应该做什么。</p><p>我也不会再对自己说“尽力就好”这样的话了。</p><p>如果再沉溺，我会永远无法看到海面上的日出。</p><p>所以，从现在开始向上游吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2024/5/4[18:28:18]&lt;br&gt;此刻，我坐在回西安的高铁上。旁边的之已经睡着了，同车厢的杰也大概在睡觉。&lt;/p&gt;
&lt;p&gt;耳机里是汪峰的《光明》。&lt;/p&gt;
&lt;p&gt;昨晚同萌和贤道了别，今早又同威说了再见。网络确实是拉进了大家的距离。不管天南海北，敲敲手机就能把我的文</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>放学</title>
    <link href="http://example.com/2024/04/20/my/"/>
    <id>http://example.com/2024/04/20/my/</id>
    <published>2024-04-20T15:31:39.000Z</published>
    <updated>2024-04-20T14:09:18.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="放学"><a href="#放学" class="headerlink" title="放学"></a>放学</h1><p>放学真的是我记忆里不可多得的快乐时光，不管是幼儿园、小学、初中还是高中，甚至是大学上完一天的课，也包括听完自己不会的知识点的网课，管我有没有听懂，反正就是很快乐。</p><p>这快乐就像吃完饭不用洗碗，睡觉不用起床，说话不计后果的快乐。尤其集中体现在收拾书包的那一刻。不管面前摆了几本书，一本两本三本都无所谓。统统塞进书包，站起身，右手提起书包的背带从自己右肩膀跨上去，顺势把书包荡到左肩，摸索着找到左边的背带。有时候啊，总是摸不到左边的背带，还要叫同桌帮我的忙。不然就是背带翻到书包外侧了，或者被压在了我的手触碰不到的地方……总之，此刻的我只背好书包就行，其他的事情交给我的腿来处理——走出教室。</p><p>不过小时候还要面临站队点名等待出校门背诵古诗等等一系列冗杂多余的形式主义行为才能走到家长有权接送的的地方。</p><p>幼儿园时候，因为我还是年纪太小，所以放学后的唯一任务就是找到妈妈爸爸或者爷爷奶奶。然后回家看电视。</p><p>二年级，老妈允许我自己从校门口走到第一个十字路口之后再回家。这样只为了初步锻炼我的自理能力。幸运的是，这里包含了学校北边所有的小卖部。极大的丰富了我的放学生活。</p><p>我在这些小卖部里买了我人生中第一本小人书。它的的确确只有巴掌大，不过，不是我十九岁的巴掌，而是我八岁的巴掌。里面的字也没有那么不清，图案也没有那么模糊，纸质也没有那么差。</p><p>我还在这里和同学们买各种各样的五毛钱一块钱的抽奖。我记得我的运气一直很好。五块钱总能抽到实际要十几块钱的金属武器，例如带刀鞘的武士刀，带皮革套的CF小刀……甚至有一次运气太好，小卖部待了好久，妈妈担心我所以直接走过来找我。最后一脸气愤地把我从小卖部里揪了出去。店员甚至还没来得及给我找钱……一代抽奖好手就此陨落。往后，那个“白雪商店”少了一个江湖传奇……</p><p>不过放学之路不仅仅只有买稀奇古怪地小东西，四年级之后的放学总是让人期待，因为我可以自己走回家了。</p><p>这也就意味着，我不仅仅可以在北边的商店买东西，我也可以去南边的商店了。</p><p>对于我来讲，南边的那家商店就是高端的代名词。文具都是高端货，除了常见的两块钱标准价格的自动铅笔，甚至上至十二块的合金自动铅笔。</p><p>十二块！</p><p>我可以买二十四包赛尔号的卡片，二十四包不同口味的辣条，甚至是一小面墙的小人书。</p><p>可是有同学用十二块只买了一支自动铅笔。不过后来让我高兴的是，在他用了一个月后，换了另一根十块钱的自动铅笔，因为他是我的好朋友，所以把那一支十二块的自动铅笔送给了我。</p><p>后来我有了压岁钱，天天买一些没有用的东西。不管吃的喝的还是玩的看的，我通通都会买来。就这样，我不到半年就花光了一千五百块钱的压岁钱。</p><p>据不完全统计，在我的印象里，我买过同一套合金尺子四套，红蓝两色各买了一套；三阶魔方四阶魔方三角魔方；乐高积木；稀奇古怪的各种东西……还有叠起来比教科书还要厚的《花火》……</p><p>奢侈！毫无节制！</p><p>这不是一个小学生该做的事，可却是一个小学生能干出来的事。</p><p>……</p><p>放学后，可不仅仅是直接回家。</p><p>指的是四点的课表结束，可这不代表没有其他课程。</p><p>要说课程，那就见外啦。这里的课程指的是由我们自己选报的课程——航模！象棋！足球！还有赶紧给我快点滚蛋的数学！</p><p>你问我为啥要报数学？拜托，没有学校可以免费放学后给你拓展课外知识的好吧。我想去学，那就必须要给学校交钱。可我哪里有钱，于是在周内的某一天，必须要学个正科。</p><p>不过，小学的数学不是轻轻松松嘛，我至今都快忘掉小学数学课都在讲什么了，它给我的印象不如语文老师带给我的声情并茂。</p><p>所以只要四点的铃声响起，那我必然是带上我的书包，去找找那些藏在学校里的科学与人文奥秘。</p><p>以上所有的快乐都集中在周内。</p><p>因为到了四年级，准确的说是准四年级的暑假——我遇到了小升初。</p><p>小升初，顾名思义，小学升初中。我啥都不知道，我只知道以后周末要去辅导班学“奥数”。</p><p>爸爸妈妈对这个事情看得十分重要，对我讲这是关系到我以后能上哪个初中。</p><p>可上哪个初中对我来说有什么区别呢。我只关心我能不能和好朋友们以后在一起玩，放学的小卖部还有没有好玩的东西，我以后还能不能见到我的同桌……</p><p>当然，周末上课也就上课吧，毕竟最多也就四个小时，这点还是可以接受的。</p><p>到了六年级，3D打印机计数问世，学校不知道从哪里请来的机构，每个班有五个人的名额去学3D打印，似乎费用不低。</p><p>理所应当，我的爸爸妈妈一向在这种方面十分支持我，我也是顺利进入了一周一次的3d打印兴趣班。</p><p>我们使用的软件是123D。那时除了win10自带的软件之外，最成熟的就是123D了。</p><p>是的，我用到了现在。不过它已经停止更新了。已经被集成迭代到另一款更加便捷的软件上去。每次想到这里，我总会想到清朝的守旧派。不过我应该迟早会使用solidwork。不能总待在自己的舒适区里，对吧。</p><p>我自然是班里最聪明的小孩，常常第一个完成作品。虽然最后的考核不尽如人意，因为我没看懂“镂空花瓶”是什么意思。</p><p>我只会做花瓶。</p><p>然而，到了一七年，也就是六年级下学期，周内开始了奥数的补习。此时，班里大部分人已经开始不上平时的课程了，开始全天待在辅导班补习。我哪里知道这是干嘛。也挤进补课的人堆里。</p><p>然而，这课还不是谁想补就能补的。我所在的奥数班，将近三百号人，只有前五十能进入一班，只有一班才能上周内的强化班，它会单独发一本习题，那上面的题都是典型难题。时常弄得我很难过。</p><p>我把表放在桌子上，比起老师的脸，我更喜欢我的手表的脸。</p><p>我说表啊，你快点走吧。</p><p>可是它总是走得好慢。</p><p>我无心看题。我百无聊赖。我神飞窗外。</p><p>然后重复。</p><p>重复上课。</p><p>重复补课。</p><p>重复放学。</p><p>直到毕业。</p><p>照了一张照片。</p><p>然后匆匆结束我不明不白的小学。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;放学&quot;&gt;&lt;a href=&quot;#放学&quot; class=&quot;headerlink&quot; title=&quot;放学&quot;&gt;&lt;/a&gt;放学&lt;/h1&gt;&lt;p&gt;放学真的是我记忆里不可多得的快乐时光，不管是幼儿园、小学、初中还是高中，甚至是大学上完一天的课，也包括听完自己不会的知识点的网课，管我有没有</summary>
      
    
    
    
    <category term="忆五六七八事" scheme="http://example.com/categories/%E5%BF%86%E4%BA%94%E5%85%AD%E4%B8%83%E5%85%AB%E4%BA%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>七.DS1302时钟模块</title>
    <link href="http://example.com/2024/03/18/DS1302%E6%97%B6%E9%92%9F%E6%A8%A1%E5%9D%97/"/>
    <id>http://example.com/2024/03/18/DS1302%E6%97%B6%E9%92%9F%E6%A8%A1%E5%9D%97/</id>
    <published>2024-03-18T11:30:22.000Z</published>
    <updated>2024-03-18T15:33:33.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DS1302时钟模块"><a href="#DS1302时钟模块" class="headerlink" title="DS1302时钟模块"></a>DS1302时钟模块</h1><h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><img src="/img/capture_20240313210312749.bmp" alt="capture_20240313210312749"></p><p> 我们可控的引脚为5，6，7，P13为复位，P23输入数据，P17为时钟引脚。其余口是已经配置好的。</p><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><p><img src="/img/capture_20240313210800767.bmp" alt="capture_20240313210800767"></p><p>如果要写入s，秒的地址为10000000（0x80），读时末位为1。</p><p>如果要写入57，用bcd码写入，把57化为16进制：0x57.</p><p>所以是先选中，再写入。</p><p>小时位如果是12小时制的，通过第三位判断上午下午。</p><p>12小时：0x12.</p><h4 id="数据地址"><a href="#数据地址" class="headerlink" title="数据地址"></a>数据地址</h4><p><img src="/img/capture_20240313211653477.bmp" alt="capture_20240313211653477"></p><p>画圈的就是读取和写入数据所调用的地址。</p><p><img src="/img/capture_20240313212159492.bmp" alt="capture_20240313212159492"></p><p>当复位拉高时才能进行数据写入</p><p>数据由上升沿开始读取，每一位是在每一个上升沿才会读。</p><h4 id="写入函数定义"><a href="#写入函数定义" class="headerlink" title="写入函数定义"></a>写入函数定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void write_ds1302(unsigned char temp)</span><br><span class="line">&#123;</span><br><span class="line">     unsigned char i;</span><br><span class="line">     for(1=0;i&lt;8;i++)</span><br><span class="line">     SCK=0;//打开复位，开始读取</span><br><span class="line">     SDA=temp&amp;0x01;//屏蔽高七位，保留最后一位为1</span><br><span class="line">     temp&gt;&gt;=1;//左移一下，此时，产生上升沿，读取第一位</span><br><span class="line">     SCK=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二次循环就是第二位为1，那就会读取第二位，循环八次，我会把我需要的数据写入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void write_ds1302_byte(unsigned char address,unsigned char dat)</span><br><span class="line">&#123;</span><br><span class="line">      RST=0; _nop_();//复位拉低，等待</span><br><span class="line">      SCK=0; _nop_();//RST拉低，等待</span><br><span class="line">      RST=1; _nop_();//复位拉高，等待</span><br><span class="line">      write_ds1302(adress);//先写地址</span><br><span class="line">      write_ds1302(dat);//再写数据</span><br><span class="line">      RST=0;//复位拉低，结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取函数定义"><a href="#读取函数定义" class="headerlink" title="读取函数定义"></a>读取函数定义</h4><p>读取的时候是下降沿。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">unsigned char Read_Ds1302_Byte ( unsigned char address )</span><br><span class="line">&#123;</span><br><span class="line"> unsigned char i,temp=0x00;</span><br><span class="line"> RST=0;_nop_();</span><br><span class="line"> SCK=0;_nop_();</span><br><span class="line"> RST=1;_nop_();</span><br><span class="line"> Write_Ds1302(address);</span><br><span class="line"> for (i=0;i&lt;8;i++) </span><br><span class="line"> &#123;</span><br><span class="line">SCK=0;</span><br><span class="line">temp&gt;&gt;=1;</span><br><span class="line"> if(SDA)//如果SDA为真1，那么temp或10000000，</span><br><span class="line"> temp|=0x80;</span><br><span class="line"> SCK=1;//拉高后</span><br><span class="line">&#125; </span><br><span class="line"> RST=0;_nop_();</span><br><span class="line"> SCK=0;_nop_();</span><br><span class="line">SCK=1;_nop_();</span><br><span class="line">SDA=0;_nop_();</span><br><span class="line">SDA=1;_nop_();</span><br><span class="line">return (temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次循环之后，我的数据为100000000，第二次循环，1右移一位，再次判断SDA,循环八次就能读出所有数据了。</p><p>值得庆幸的是，这两个底层官方在赛点数据包里提供了。</p><h2 id="外设添加"><a href="#外设添加" class="headerlink" title="外设添加"></a>外设添加</h2><p>在赛点资源包里添加头文件<img src="/img/capture_20240313215714693.bmp" alt="capture_20240313215714693"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DS1302时钟模块&quot;&gt;&lt;a href=&quot;#DS1302时钟模块&quot; class=&quot;headerlink&quot; title=&quot;DS1302时钟模块&quot;&gt;&lt;/a&gt;DS1302时钟模块&lt;/h1&gt;&lt;h2 id=&quot;原理图&quot;&gt;&lt;a href=&quot;#原理图&quot; class=&quot;header</summary>
      
    
    
    
    <category term="蓝桥杯" scheme="http://example.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>六.倒计时程序</title>
    <link href="http://example.com/2024/03/16/%E5%80%92%E8%AE%A1%E6%97%B6%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2024/03/16/%E5%80%92%E8%AE%A1%E6%97%B6%E7%A8%8B%E5%BA%8F/</id>
    <published>2024-03-16T11:30:22.000Z</published>
    <updated>2024-03-18T15:33:38.677Z</updated>
    
    <content type="html"><![CDATA[<p>倒计时程序</p><p>定义变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint Timer_1000ms;</span><br><span class="line">uchar Timer_count = 30;//计时变量，此处为30</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*中断程序内*/</span><br><span class="line">if(++Timer_1000ms == 1000)</span><br><span class="line">&#123;   </span><br><span class="line"> Timer_1000ms = 0;</span><br><span class="line"> Timer_count--;//1s减一次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>信息处理函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seg_buf[4] = Timer_count / 10 % 10;//取十位</span><br><span class="line">seg_buf[5] = Timer_count % 10;//取个位</span><br></pre></td></tr></table></figure><p>数码管第四位第五位便会显示倒数计时30.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;倒计时程序&lt;/p&gt;
&lt;p&gt;定义变量&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="蓝桥杯" scheme="http://example.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>五.蓝桥杯大模板</title>
    <link href="http://example.com/2024/03/15/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%A7%E6%A8%A1%E6%9D%BF/"/>
    <id>http://example.com/2024/03/15/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%A7%E6%A8%A1%E6%9D%BF/</id>
    <published>2024-03-15T11:30:22.000Z</published>
    <updated>2024-03-18T15:29:32.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蓝桥杯大模板"><a href="#蓝桥杯大模板" class="headerlink" title="蓝桥杯大模板"></a>蓝桥杯大模板</h1><h3 id="工程文件夹的建立"><a href="#工程文件夹的建立" class="headerlink" title="工程文件夹的建立"></a>工程文件夹的建立</h3><p><img src="/img/capture_20240312194726442.bmp" alt="capture_20240312194726442"></p><p>首先建立文件夹，包含两个文件夹</p><p>接着new project，命名文件为LED，选择芯片</p><p><img src="/img/capture_20240312194901674.bmp" alt="capture_20240312194901674"></p><p><strong>魔术棒勾选生成HEX文件</strong>魔术棒选择头文件路径<strong>Driver</strong></p><p><img src="/img/capture_20240312195554597.bmp" alt="capture_20240312195554597"></p><h3 id="底层文件的编写"><a href="#底层文件的编写" class="headerlink" title="底层文件的编写"></a>底层文件的编写</h3><h4 id="1-第一个底层：init（初始化）"><a href="#1-第一个底层：init（初始化）" class="headerlink" title="1.第一个底层：init（初始化）"></a>1.第一个底层：init（初始化）</h4><p>两个文件</p><p>init.c和init.h</p><p><strong>.h文件引用自身的头文件</strong></p><p><img src="/img/capture_20240312200807732.bmp" alt="capture_20240312200807732"></p><p><img src="D/img/capture_20240312200800202.bmp" alt="capture_20240312200800202"></p><p>双击driver，把init.c引用进文件夹。并在c引用h自身，h文件引用单片机型号头文件</p><p>初始化函数（关闭继电器蜂鸣器）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;init.h&gt;</span><br><span class="line">void system_init()</span><br><span class="line">&#123;</span><br><span class="line">    P0 = 0xff;//开锁存器</span><br><span class="line">    P2 = P2 &amp; 0x1f | 0x80;</span><br><span class="line">P2 &amp;= 0x1f;//用完即关</span><br><span class="line">P0 = 0x00;</span><br><span class="line">    P2 = P2 &amp; 0x1f | 0xa0;</span><br><span class="line">P2 &amp;= 0x1f;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>接着在.h里声明该函数：</p><p><img src="/img/capture_20240312203553010.bmp" alt="capture_20240312203553010"></p><h4 id="第二个底层：LED-c"><a href="#第二个底层：LED-c" class="headerlink" title="第二个底层：LED.c"></a>第二个底层：LED.c</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;LED.h&gt;</span><br><span class="line"> void LED_disp(unsigned char addr,enable)</span><br><span class="line"> </span><br><span class="line"> &#123;</span><br><span class="line"> static unsigned char temp = 0x00;</span><br><span class="line"> static unsigned char temp_old = 0xff;</span><br><span class="line"> if(enable)</span><br><span class="line"> temp |= 0x01 &lt;&lt; addr;</span><br><span class="line"> else</span><br><span class="line"> temp &amp;=~(0x01 &lt;&lt; addr);</span><br><span class="line"> if(temp != temp_old)</span><br><span class="line"> &#123;</span><br><span class="line">      P0 = ~temp;</span><br><span class="line">  P2 = P2 &amp; 0x1f | 0x80;</span><br><span class="line">  P2 = P2 &amp; 0x1f;</span><br><span class="line">  temp_old = temp; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>仍然是两个文件。</p><p>双击driver，把LED.c引用进文件夹。并在c引用h自身，h文件引用单片机型号头文件</p><p><img src="/img/capture_20240312205801226.bmp" alt="capture_20240312205801226"></p><h4 id="第三个底层：独立按键和矩阵键盘"><a href="#第三个底层：独立按键和矩阵键盘" class="headerlink" title="第三个底层：独立按键和矩阵键盘"></a>第三个底层：独立按键和矩阵键盘</h4><p>.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Key.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned char Key_Read()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char temp = 0;</span><br><span class="line">P44 = 0;P42 = 1;P35 = 1;P34 = 1;//第一列（0为选中）</span><br><span class="line">if(P33 == 0) temp = 4;</span><br><span class="line">if(P32 == 0) temp = 5;</span><br><span class="line">if(P31 == 0) temp = 6;</span><br><span class="line">if(P30 == 0) temp = 7;</span><br><span class="line">P44 = 1;P42 = 0;P35 = 1;P34 = 1;//第二列</span><br><span class="line">if(P33 == 0) temp = 8;</span><br><span class="line">if(P32 == 0) temp = 9;</span><br><span class="line">if(P31 == 0) temp = 10;</span><br><span class="line">if(P30 == 0) temp = 11;</span><br><span class="line">P44 = 1;P42 = 1;P35 = 0;P34 = 1;第三列</span><br><span class="line">if(P33 == 0) temp = 12;</span><br><span class="line">if(P32 == 0) temp = 13;</span><br><span class="line">if(P31 == 0) temp = 14;</span><br><span class="line">if(P30 == 0) temp = 15;</span><br><span class="line">P44 = 1;P42 = 1;P35 = 1;P34 = 0;//第四列</span><br><span class="line">if(P33 == 0) temp = 16;</span><br><span class="line">if(P32 == 0) temp = 17;</span><br><span class="line">if(P31 == 0) temp = 18;</span><br><span class="line">if(P30 == 0) temp = 19;</span><br><span class="line">return temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，独立按键和矩阵按键是通过开发板的跳线帽进行选择的。</p><p><img src="/img/capture_20240312215145294.bmp" alt="capture_20240312215145294"></p><p>但是仿真的芯片并非蓝桥比赛的板子，矩阵按键有些端口和蓝桥不一样，这里我们以蓝桥的板子为主。</p><h4 id="第四个底层：共阳极数码管"><a href="#第四个底层：共阳极数码管" class="headerlink" title="第四个底层：共阳极数码管"></a>第四个底层：共阳极数码管</h4><p>.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Seg.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned char seg_dula[] = &#123;0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,0x88&#125;;</span><br><span class="line">unsigned char seg_wela[] = &#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80&#125;;</span><br><span class="line"></span><br><span class="line">void Seg_Disp(unsigned char wela,dula,point)</span><br><span class="line">&#123;</span><br><span class="line">P0 = 0xff;</span><br><span class="line">P2 = P2 &amp; 0x1f | 0xe0;</span><br><span class="line">P2 &amp;= 0x1f;</span><br><span class="line"></span><br><span class="line">P0 = seg_wela[wela];</span><br><span class="line">P2 = P2 &amp; 0x1f | 0xc0;</span><br><span class="line">P2 &amp;= 0x1f;</span><br><span class="line"></span><br><span class="line">P0 = seg_dula[dula];</span><br><span class="line">if(point)</span><br><span class="line">P0 &amp;= 0x7f;</span><br><span class="line">P2 = P2 &amp; 0x1f | 0xe0;</span><br><span class="line">P2 &amp;= 0x1f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟练使用ISP烧录工具，内含部分范例程序。</p><h3 id="主函数建立"><a href="#主函数建立" class="headerlink" title="主函数建立"></a>主函数建立</h3><p>分别引用之前的两个底层到主函数里，我们测试led模块和初始化是否正常：</p><p><img src="/img/capture_20240312213044098.bmp" alt="capture_20240312213044098"></p><p>第一位是第几个（第一位是0，第二位是1.）第二位是是否亮（1为亮）</p><p>放入仿真里运行</p><p><img src="/img/capture_20240312213229762.bmp" alt="capture_20240312213229762"></p><p>十分稳健。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;蓝桥杯大模板&quot;&gt;&lt;a href=&quot;#蓝桥杯大模板&quot; class=&quot;headerlink&quot; title=&quot;蓝桥杯大模板&quot;&gt;&lt;/a&gt;蓝桥杯大模板&lt;/h1&gt;&lt;h3 id=&quot;工程文件夹的建立&quot;&gt;&lt;a href=&quot;#工程文件夹的建立&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="蓝桥杯" scheme="http://example.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>四.独立按键和矩阵键盘</title>
    <link href="http://example.com/2024/03/03/%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%E5%92%8C%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98/"/>
    <id>http://example.com/2024/03/03/%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%E5%92%8C%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98/</id>
    <published>2024-03-03T12:20:22.000Z</published>
    <updated>2024-03-03T14:59:51.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="独立按键和矩阵键盘"><a href="#独立按键和矩阵键盘" class="headerlink" title="独立按键和矩阵键盘"></a>独立按键和矩阵键盘</h1><h2 id="原理图："><a href="#原理图：" class="headerlink" title="原理图："></a>原理图：</h2><p><img src="/img/capture_20240303182545985.bmp" alt="capture_20240303182545985"></p><p>由原理图可以知道，独立按键和矩阵键盘有些线是接在一起的。</p><p>我们看到板子实物，会看到可更改的跳线帽。当2，3跳线帽接在一起时，启用的是独立按键。</p><h2 id="独立按键"><a href="#独立按键" class="headerlink" title="独立按键"></a>独立按键</h2><p>接下来我们简化独立按键原理图：</p><p><img src="/img/capture_20240303182953055.bmp" alt="capture_20240303182953055"></p><p>从上到下依次是S7、S6、S5、S4,所有按键可以同时输入与输出（区别于stm32)。</p><h4 id="输入读取"><a href="#输入读取" class="headerlink" title="输入读取"></a>输入读取</h4><p>按键按下为低电平，程序选择表达为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(s7 == 0)</span><br><span class="line">&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当按键没有按下时，为高电平。（此处涉及到单片机IO口的结构和电路分析基础，此处不做过多研究。PS：我也研究不明白。）</p><p>另外，单片机按键会出现抖动，这是由于单片机按键的机械原因，其按键具有弹性，断开与闭合时均会因为弹性作用，不会马上稳定的接通，最大抖动时常为（5-10ms)+(5-10ms)。</p><p>此外，单片机的输入高电平为5v，输出为0v，但输出的高低电平均为一个范围。</p><p><img src="/img/capture_20240303184405576.bmp" alt="capture_20240303184405576"></p><p>用示波器检测，我们即可发现其抖动的状态。</p><p>如果我们要消除抖动，在判断为按键按下时候加一个10ms的延时函数即可。</p><h4 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h4><p>定义端口;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sbit S7 = P3^0;</span><br><span class="line">sbit S6 = P3^1;</span><br><span class="line">sbit S5 = P3^2;</span><br><span class="line">sbit S4 = P3^3;</span><br></pre></td></tr></table></figure><p>定义函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void keyscan()//按键扫描函数</span><br><span class="line">&#123;   hc573(4);//开LED锁存器通道</span><br><span class="line">    if （S7 == 0）;</span><br><span class="line">    &#123;</span><br><span class="line">       P0 = 0xfe;//亮第一个灯</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;   </span><br><span class="line">   init();</span><br><span class="line">   while(1)</span><br><span class="line">   &#123;</span><br><span class="line">       keyscan();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得改跳线帽哦。</p><h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><p>1.按下S7亮灯，松开熄灭</p><pre><code>  void keyscan()//按键扫描函数&#123;       hc573(4);//开LED锁存器通道    if （S7 == 0）;    &#123;       P0 = 0xfe;//亮第一个灯       while(S7==0);//不松手的话就会一直卡在循环里，即一直亮第一个灯。       P0 = 0xff;    &#125; &#125;  </code></pre><p>2.按下S7，L1亮，再按下S7，L1灭</p><p>这里我们使用一个计分板：state</p><p>当state为0，led亮，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">uchar state;//keil5初始值默认为0</span><br><span class="line"></span><br><span class="line">void led()</span><br><span class="line">&#123;</span><br><span class="line">      hc573(4);</span><br><span class="line">      if(state == 0)//按第一次state为0，第二次为1</span><br><span class="line">      &#123;</span><br><span class="line">      P0 = 0xff;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">      P0 = 0xfe; </span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line">       </span><br><span class="line">void keyscan()//按键扫描函数</span><br><span class="line">   &#123;   </span><br><span class="line">    if (S7 == 0);</span><br><span class="line">      &#123;  </span><br><span class="line">        delay_ms(10);等待10ms再次确认</span><br><span class="line">        if (S7 == 0);//消抖</span><br><span class="line">        &#123;</span><br><span class="line">         state = 1 - state;</span><br><span class="line">         while(S7==0);</span><br><span class="line">         delay_ms(10);</span><br><span class="line">         while(S7==0);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">void main()</span><br><span class="line">&#123;   </span><br><span class="line">   init();</span><br><span class="line">   while(1)</span><br><span class="line">   &#123;</span><br><span class="line">       keyscan();</span><br><span class="line">       led();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.第一次按S7，L1亮，第二次按，L1以500ms闪烁，第三次熄灭。</p><p>整体思路不变，依然是用state，不过这次需要三个数，我们可以这样改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void keyscan()//按键扫描函数</span><br><span class="line">   &#123;   </span><br><span class="line">    if (S7 == 0);</span><br><span class="line">      &#123;   </span><br><span class="line">        if (S7 == 0);//消抖</span><br><span class="line">        &#123;</span><br><span class="line">         delay_ms(10);</span><br><span class="line">                                                            // state = 1 - state;</span><br><span class="line">        if (state == 0)</span><br><span class="line">        &#123;</span><br><span class="line">          state = 1; </span><br><span class="line">        &#125;</span><br><span class="line">        else if (state == 1)</span><br><span class="line">        &#123;</span><br><span class="line">        state = 2;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (state ==2)</span><br><span class="line">        &#123;</span><br><span class="line">        state = 0; </span><br><span class="line">        &#125;</span><br><span class="line">         while(S7==0);</span><br><span class="line">         delay_ms(10);</span><br><span class="line">         while(S7==0);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void keyscan()//按键扫描函数</span><br><span class="line"> &#123;   </span><br><span class="line">  if (S7 == 0);</span><br><span class="line">    &#123;    </span><br><span class="line">      delay_ms(10);</span><br><span class="line">      if (S7 == 0);//消抖</span><br><span class="line">      &#123;</span><br><span class="line">       state = 1 + state;</span><br><span class="line">       if(state == 3)//第四次state值为3，初始化为0继续循环</span><br><span class="line">          &#123;</span><br><span class="line">            state = 0;</span><br><span class="line">          &#125;</span><br><span class="line">       while(S7==0);</span><br><span class="line">       delay_ms(10);</span><br><span class="line">       while(S7==0);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;  </span><br></pre></td></tr></table></figure><p>两个改法核心思路都是：</p><p>第一次state值为0，执行亮L1操作，第二次按下state值为执行闪烁操作，第三次state为2，执行熄灭，第四次自动把state值改为0，再重新进入循环。</p><p>led部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void led()</span><br><span class="line">&#123;</span><br><span class="line">      hc573(4);</span><br><span class="line">      if(state == 0)</span><br><span class="line">      &#123;</span><br><span class="line">      P0 = 0xfe;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (state == 1)</span><br><span class="line">      &#123;      </span><br><span class="line">       P0 = 0xff;</span><br><span class="line">       delay_ms(500);</span><br><span class="line">       P0 = 0xfe;</span><br><span class="line">       delay_ms(500);       </span><br><span class="line">      &#125;</span><br><span class="line">      else if (state == 2)</span><br><span class="line">      &#123;</span><br><span class="line">        P0 = 0xff;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后我们写入单片机，我们发现，第三次无法实现。</p><p>这里，我们需要定时器中断</p><p>解释原因:</p><p>我们的程序执行过程是这样的：</p><p>1.keyscan</p><p>2.led</p><p>​       P0 = 0xff;<br>​       delay_ms(500);<br>​       P0 = 0xfe;<br>​       delay_ms(500);   //这个过程是每次执行完才去检测按键函数。</p><p>所以说，在这每次循环完闪烁之后，只有极短的时间去检测按键，但这个时间不足以让人的手去按下按键。</p><p>这样，我们的函数state==1就会一直循环下去。除非某次它刚好执行完，你刚好按下按键并且被它检测到，才会停止循环，执行state==2.</p><p>那怎么样才能加大我们被检测到的概率呢？</p><p>别忘了，delay_ms(500)函数是1ms的函数循环500次，只要我们把按键检测塞到这个循环里去，那我们被检测的概率将大大提高。</p><p>延时函数： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Delay_ms(uint xms)//@12MHz</span><br><span class="line">&#123;     </span><br><span class="line">     for (  ;  xms &gt; 0; xms--)</span><br><span class="line">   &#123;</span><br><span class="line">unsigned char i, j;</span><br><span class="line">i = 12;</span><br><span class="line">j = 169;</span><br><span class="line"> do</span><br><span class="line"> &#123;</span><br><span class="line">while (--j);</span><br><span class="line">  &#125; while (--i);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>不过，我们仅仅是在按键时候检测，所以不破坏原本延时函数，复制后改个名整个新的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Delay_msl(uint xms)</span><br><span class="line">&#123;     </span><br><span class="line">     for (  ;  xms &gt; 0; xms--)</span><br><span class="line">   &#123;</span><br><span class="line">unsigned char i, j;</span><br><span class="line">i = 12;</span><br><span class="line">j = 169;</span><br><span class="line"> do</span><br><span class="line"> &#123;  keyscan();//插入按键检测函数</span><br><span class="line">while (--j);</span><br><span class="line">  &#125; while (--i);</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>记得把keyscan放在新的延时函数之前。否则编译会出错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;独立按键和矩阵键盘&quot;&gt;&lt;a href=&quot;#独立按键和矩阵键盘&quot; class=&quot;headerlink&quot; title=&quot;独立按键和矩阵键盘&quot;&gt;&lt;/a&gt;独立按键和矩阵键盘&lt;/h1&gt;&lt;h2 id=&quot;原理图：&quot;&gt;&lt;a href=&quot;#原理图：&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="蓝桥杯" scheme="http://example.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>三.共阳数码管</title>
    <link href="http://example.com/2024/03/02/%E5%85%B1%E9%98%B3%E6%95%B0%E7%A0%81%E7%AE%A1/"/>
    <id>http://example.com/2024/03/02/%E5%85%B1%E9%98%B3%E6%95%B0%E7%A0%81%E7%AE%A1/</id>
    <published>2024-03-02T12:20:22.000Z</published>
    <updated>2024-03-03T14:59:58.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="共阳数码管"><a href="#共阳数码管" class="headerlink" title="共阳数码管"></a>共阳数码管</h2><p>数码管就是由LED组成的。<img src="/img/capture_20240229204119212.bmp" alt="capture_20240229204119212"></p><p>每个数码管的代号如图所示，按abcd顺时针走一圈即可。我们让P0=0x00就能点亮所有数码管（per)。</p><p>如果我们要让数码管成为一个2，那么就是</p><div class="table-container"><table><thead><tr><th>dp</th><th>g</th><th>f</th><th>e</th><th>d</th><th>c</th><th>b</th><th>a</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr></tbody></table></div><p>换算为十六进制就是<strong>（从右向左！！！！）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P0=0xa4;</span><br></pre></td></tr></table></figure><p>同理，0的话就是</p><div class="table-container"><table><thead><tr><th>dp</th><th>g</th><th>f</th><th>e</th><th>d</th><th>c</th><th>b</th><th>a</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><p>即:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P0=0xc0;</span><br></pre></td></tr></table></figure><p>不过听说比赛的时候赛点资源包里面是有数码管数字的十六进制的…..</p><p>接下来我们看原理图。</p><p><img src="/img/capture_20240229205434728.bmp" alt="capture_20240229205434728"></p><p>控制数码管，我们是由com公共端控制的，<img src="/img/capture_20240229205721961.bmp" alt="capture_20240229205434728"></p><p>abcd口由U7控制。端口连接情况如图所示，依然存在<strong>锁存器</strong>，依然存在<strong>或非门</strong>。</p><p>com连接情况也是显而易见。由U8控制。</p><p>不过需要注意的是，我们一共有8个数码管，每个阴极a和a，b和b都是接在一起的，如果我们需要显示0，那所有数码管都会只显示0。</p><p>因此，需要的线不是72个，而是16根线。具体如何操作我们后面再说。</p><h2 id="静态数码管"><a href="#静态数码管" class="headerlink" title="静态数码管"></a>静态数码管</h2><p>下面我们开始写代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#define uint unsigned int</span><br><span class="line">#define uchar unsignded char</span><br><span class="line">sbit LSA =P2^5;</span><br><span class="line">sbit LSB =P2^6;</span><br><span class="line">sbit LSC=P2^7;</span><br><span class="line">code uchaar segment[10] = (0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90);//把十个数码管的数字十六进制放进一个叫 segment的数组里去。code 意思就是我们以后不会再更改它了。</span><br></pre></td></tr></table></figure><p><img src="/img/capture_20240302100404991.bmp" alt="capture_20240302100404991"></p><p>当我们编译成功时，会看到下面状态栏里的内容<img src="/img/capture_20240302100821624.bmp" alt="capture_20240302100821624"></p><p>date是程序变量大小，xdate是外部存储器，code是存放了我们刚才的数组。</p><p>我们上一次学习了LED，蜂鸣器和继电器，每次我们都要重新定义<strong>573锁存器</strong>的输出，所以，我们写一个新的函数，用来调用我们需要的功能。</p><p>函数定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void hc573(unchar channel)</span><br><span class="line">&#123;</span><br><span class="line">    switch(channel)</span><br><span class="line">    &#123;</span><br><span class="line">      case 4:LSC = 1;LSB = 0; LEA = 0;break;</span><br><span class="line">      case 5:LSC = 1;LSB = 0; LEA = 1;break;//LED</span><br><span class="line">      case 6:LSC = 1;LSB = 1; LEA = 0;break;//数码管</span><br><span class="line">      case 7:LSC = 1;LSB = 0; LEA = 1;break;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void init ()</span><br><span class="line">&#123;</span><br><span class="line">   hc573(5);</span><br><span class="line">   P0 =Ox00;//控制第几个数码管量</span><br><span class="line">   hc573(4);</span><br><span class="line">   P0 = 0xff;//数码管显示8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义数码管函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void SMG(uchar seg)</span><br><span class="line">&#123;</span><br><span class="line">  hc573(6);  </span><br><span class="line">  P0 = 0xff;</span><br><span class="line">  hc573(7);</span><br><span class="line">  P0 = segment[seg];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> init();</span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">         SMG[7];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们的数码管就会全部显示数字7了。</p><h2 id="动态数码管"><a href="#动态数码管" class="headerlink" title="动态数码管"></a>动态数码管</h2><p>首先，我们的数码管是没法同时显示不同数字的。</p><p>那我们该怎么样才能让数码管同时显示不同数字呢？</p><p>我们没法改变数码管，但能用数码管欺骗我们的眼睛。</p><p>我们可以让第一个数码管显示1，然后熄灭其他数码管，再过1ms.让第二个数码管显示2，同时熄灭第一个和其他数码管，如此循环往复，就能欺骗我们的眼睛了。</p><p>这个效果叫做，<strong>余晖效应</strong>。</p><p>我们开始改代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void SMG(uchar pos,seg)</span><br><span class="line">&#123;</span><br><span class="line">  hc573(6);  </span><br><span class="line">  P0 = 0x01&lt;&lt; （pos-1）;//（数码管位选）让一个数码管亮，pos是1，第二个pos为2.</span><br><span class="line">  hc573(7);//数码管段选</span><br><span class="line">  P0 = segment[seg];</span><br><span class="line">  delay_ms(1);//记得在前面定义一个延时函数嗷</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义显示数字：20240302</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void display()</span><br><span class="line">&#123;</span><br><span class="line">   SMG(1,2);//第一位是位选，第二位是段选，这一行的意思是第一个数码管显示2</span><br><span class="line">   SMG(2,0);</span><br><span class="line">   SMG(3,2);</span><br><span class="line">   SMG(4,4);</span><br><span class="line">   SMG(5,0);</span><br><span class="line">   SMG(6,3);</span><br><span class="line">   SMG(7,0);</span><br><span class="line">   SMG(8,2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> init();</span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">         display();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就完成了。</p><p>不过，我们会发现，没有亮的地方有残影。</p><p>这里，我们就需要进行<strong>数码管消隐</strong>。</p><h2 id="数码管消隐"><a href="#数码管消隐" class="headerlink" title="数码管消隐"></a>数码管消隐</h2><p>出现的原因就是先进行位选，再进行段选，进行第二次循环的时候，上一次段选的状态会延续到我下一次位选。这样就会出现残影。</p><p>解决方法就是直接在每一次循环的时候，在位选前面加一次段选，令P0 = 0xff；</p><p>于是，我们进行消隐处理后的代码就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void SMG(uchar pos,seg)</span><br><span class="line">&#123;</span><br><span class="line">  hc573(7);         //消隐</span><br><span class="line">  P0 = 0xff;</span><br><span class="line">  hc573(6);         //数码管位选</span><br><span class="line">  P0 = 0x01&lt;&lt; （pos-1）;</span><br><span class="line">  hc573(7);         //数码管段选</span><br><span class="line">  P0 = segment[seg];</span><br><span class="line">  delay_ms(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数码管特殊字符"><a href="#数码管特殊字符" class="headerlink" title="数码管特殊字符"></a>数码管特殊字符</h2><h4 id="字母"><a href="#字母" class="headerlink" title="字母"></a>字母</h4><p>字母的话我们和数字方法一样，这里不过多赘述。</p><p>当我们需要调用的时候，记得在我们放入字母的segment数组中进行调用。</p><p>我们的数码管显示函数是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void display()</span><br><span class="line">&#123;</span><br><span class="line">   SMG(1,2);</span><br><span class="line">   SMG(2,0);</span><br><span class="line">   SMG(3,2);</span><br><span class="line">   SMG(4,4);</span><br><span class="line">   SMG(5,0);</span><br><span class="line">   SMG(6,11);//后三个数码管就会显示我们已经编辑好的字符。</span><br><span class="line">   SMG(7,12);</span><br><span class="line">   SMG(8,13);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小数点"><a href="#小数点" class="headerlink" title="小数点"></a>小数点</h4><p>如果是显示小数点的话，那我们让dp输出为0就好了，这样的话我的数字要全部重新写。当然我们还有更加便捷的方法。</p><p>我们先举个<strong>狸子</strong>：</p><p>如果是显示数字1</p><p>11111001</p><p>变为</p><p>01111001</p><p>这里改变的只有最后一位，所以我们的思路就是保留前七位，更改最后一位。</p><p>这里我们使用&amp;运算符。</p><p>&amp;和1效果为保留，&amp;0效果就是清除。</p><p>所以，我们搞出来一个</p><p>01111111就可以把最后一位的dp位置清除为0.</p><p>所以，我们的代码更改为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void SMG(uchar pos,seg)</span><br><span class="line">&#123;</span><br><span class="line">  hc573(7);        </span><br><span class="line">  P0 = 0xff;</span><br><span class="line">  hc573(6);         </span><br><span class="line">  P0 = 0x01 &lt;&lt; （pos-1）;</span><br><span class="line">  hc573(7);        </span><br><span class="line">  P0 = segment[seg];</span><br><span class="line">  delay_ms(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SMG1(uchar pos,seg)//让每一数字显示小数点</span><br><span class="line">&#123;</span><br><span class="line">  hc573(7);         </span><br><span class="line">  P0 = 0xff;</span><br><span class="line">  hc573(6);        </span><br><span class="line">  P0 = 0x01 &lt;&lt; （pos-1）;</span><br><span class="line">  hc573(7);        </span><br><span class="line">  P0 = segment[seg]&amp;0x7f;//清除最后一位</span><br><span class="line">  delay_ms(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示函数更改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void display()</span><br><span class="line">&#123;</span><br><span class="line">   SMG(1,2);</span><br><span class="line">   SMG(2,0);</span><br><span class="line">   SMG(3,2);</span><br><span class="line">   SMG(4,4);</span><br><span class="line">   SMG(5,0);</span><br><span class="line">   SMG1(6,11);//这样就好了。</span><br><span class="line">   SMG1(7,12);</span><br><span class="line">   SMG1(8,13);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;共阳数码管&quot;&gt;&lt;a href=&quot;#共阳数码管&quot; class=&quot;headerlink&quot; title=&quot;共阳数码管&quot;&gt;&lt;/a&gt;共阳数码管&lt;/h2&gt;&lt;p&gt;数码管就是由LED组成的。&lt;img src=&quot;/img/capture_20240229204119212.bmp&quot;</summary>
      
    
    
    
    <category term="蓝桥杯" scheme="http://example.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>二.继电器和蜂鸣器</title>
    <link href="http://example.com/2024/02/29/%E8%9C%82%E9%B8%A3%E5%99%A8%E5%92%8C%E7%BB%A7%E7%94%B5%E5%99%A8/"/>
    <id>http://example.com/2024/02/29/%E8%9C%82%E9%B8%A3%E5%99%A8%E5%92%8C%E7%BB%A7%E7%94%B5%E5%99%A8/</id>
    <published>2024-02-29T13:45:32.000Z</published>
    <updated>2024-03-03T14:54:17.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="蜂鸣器和继电器"><a href="#蜂鸣器和继电器" class="headerlink" title="蜂鸣器和继电器"></a>蜂鸣器和继电器</h2><h4 id="继电器"><a href="#继电器" class="headerlink" title="继电器"></a>继电器</h4><p>原理图：</p><p><img src="/img/屏幕截图 2024-03-02 000621.png" alt="屏幕截图 2024-02-29 195227"></p><p>原理：通电导线产生磁场，把K1吸下来。</p><p>可以理解为单刀双掷开关。K1控制m1和m2。</p><p>只要让N RELAY低电平即可。</p><p>这个二极管的作用大概是当断电的时候，保护电路？</p><h4 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h4><p><img src="/img/capture_20240229195647734.bmp" alt="capture_20240229195647734"></p><p>让蜂鸣器工作的话只要在N BUZZ接入低电平即可。</p><p>然后我们在原理图上找这两个口。</p><p><img src="/img/capture_20240229200511192.bmp" alt="capture_20240229200511192"></p><p>ULN2003是双极型线性集成电路。</p><p>内部原理就是一个非门。</p><p>输入高输出低，输入低输出高。如果用它来控制电机，那么只能实现单方向的控制。</p><p>左边还是一个锁存器。</p><p>于是通路就是：</p><p>N RELAY—-P04—-Y5C</p><p>Y5C和一个或非门连在一起，由Y5控制</p><p><img src="/img/capture_20240229201850805.bmp" alt="capture_20240229201850805"></p><p>Y5的尽头是一个译码器，我们之前说过了。</p><p><img src="/img/capture_20240229201842286.bmp" alt="capture_20240229201842286"></p><p>所以，最终我们让这三个口从下到上依次取值101，Y5最终就会输出一个低电平，Y5C就是高电平。</p><p>最后，我们让P00-P07取值为00001000，换算为十六进制为10</p><p>即:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P0 = 0x10;</span><br></pre></td></tr></table></figure><p>同理，我们让继电器打开的话，P0-P7取值为01000000，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P0 = 0x40;</span><br></pre></td></tr></table></figure><p>都打开的话就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P0=0x50;</span><br></pre></td></tr></table></figure><p>都关闭的话就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P0=0x00;</span><br></pre></td></tr></table></figure><p>最后注意LED和继电器的初始化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;蜂鸣器和继电器&quot;&gt;&lt;a href=&quot;#蜂鸣器和继电器&quot; class=&quot;headerlink&quot; title=&quot;蜂鸣器和继电器&quot;&gt;&lt;/a&gt;蜂鸣器和继电器&lt;/h2&gt;&lt;h4 id=&quot;继电器&quot;&gt;&lt;a href=&quot;#继电器&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="蓝桥杯" scheme="http://example.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>一.LED的点亮</title>
    <link href="http://example.com/2024/02/28/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    <id>http://example.com/2024/02/28/%E8%93%9D%E6%A1%A5%E6%9D%AF/</id>
    <published>2024-02-28T15:39:22.000Z</published>
    <updated>2024-03-03T14:54:04.277Z</updated>
    
    <content type="html"><![CDATA[<p>蓝桥杯</p><p>一.LED以及锁存器的跟随模式，io模式vcc或非门，keil新建项目文件以及第一个程序</p><p><img src="/img/capture_20240228192033725.bmp" alt="capture_20240228192033725"></p><p>led有八个灯珠，右边vcc为正极供电，因此，只需要控制左边负极为低电平，即可控制led。</p><p>但是在led左边有一个M74hc573锁存器。</p><p>简单来说，就是由输入引脚D1-D8，来控制输出引脚Q1-Q8，OE和LE的取值会影响输入数据控制输出数据。</p><p>当OE为L（低电平0v）时，LE为高电平H，为跟随模式，即输出数据=输入数据。</p><p>OE为L时，LE为低电平L时，为锁存模式，即输出数据=上一个时刻的输入数据。</p><p>我们这个锁存器的OE已经接了地，也就是说已经接了低电平，那我们只需要控制LE为高电平即可。</p><p>但是，这里LE接了一个”Y4C”，我们使用全局搜素，在原理图下面找到了另一个Y4C.<img src="/img/capture_20240228192602249.bmp" alt="capture_20240228192602249"></p><p>这是一个或非门，蓝桥杯比赛中，WR和GND是接在一起的，也就是说，WR固定为0，如果Y4(12)为0，Y4C则输出高电平，反之则低电平。<img src="/img/capture_20240228194518765.bmp" alt="capture_20240228194518765"></p><p>74HC02的Y4口又和U24接在一起，这个东西叫做74HC138译码器，</p><p>左边从上到下，如果为000，换为二进制则Y0口输出为低电平，Y1-Y7为高电平。</p><p>001，Y1口0其余1。</p><p>010，Y2口0其余1</p><p>011，Y3口0其余1….</p><p>100，Y4口0其余1</p><p>新建项目文件：：</p><p>代码开始：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">sbit LSA =P2^5;</span><br><span class="line">sbit LSB =P2^6;</span><br><span class="line">sbit LSC=P2^7;</span><br><span class="line">sbit L1 = P0^0;</span><br><span class="line">sbit L2 = P0^1;</span><br><span class="line">sbit L3 = P0^2;</span><br><span class="line">sbit L4 = P0^3;</span><br><span class="line">sbit L5 = P0^4;</span><br><span class="line">sbit L6 = P0^5;</span><br><span class="line">sbit L7 = P0^6;</span><br><span class="line">sbit L8 = P0^7;</span><br><span class="line">void init()//不过，我们的蜂鸣器会乱响，这里我们加入一点东西（我看不懂思密达，反正就是加了）</span><br><span class="line">&#123;</span><br><span class="line">LSC=1;LSB =0;LSA=1;</span><br><span class="line">P0=0x00;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;        init()//这一行也是加的</span><br><span class="line">​        LSC=LSA=LSB;</span><br><span class="line">​        L1=0;</span><br><span class="line">​        L2=L3=L4=L5=L6=L7=L8=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LSAbc为锁存器部分，P0为LED部分，另外一定要在程序里加上while，确保单片机的程序可以重复运行。</p><h4 id="延时函数"><a href="#延时函数" class="headerlink" title="延时函数:"></a>延时函数:</h4><p>在isp烧录软件里找到延时函数，选择12mhz，定时长度为1s</p><p><img src="/img/capture_20240228201640366.bmp" alt="capture_20240228201640366"></p><p>先把整个复制下来，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">()</span><span class="comment">//@12MHz</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line">i = <span class="number">12</span>;</span><br><span class="line">j = <span class="number">169</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此之前，为了方便起见，宏定义两个快捷操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uchar unsignded char</span></span><br></pre></td></tr></table></figure><p>把延时函数变量改为 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Delay_ms(uint xms)</span><br></pre></td></tr></table></figure><p>我们希望它延时多少毫秒，就把它循环几次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (  ;  xms &gt; 0; xms--)</span><br></pre></td></tr></table></figure><p>于是，延时函数就变成了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(uint xms)</span><span class="comment">//@12MHz</span></span><br><span class="line">&#123;     </span><br><span class="line">     <span class="keyword">for</span> (  ;  xms &gt; <span class="number">0</span>; xms--)</span><br><span class="line">​      &#123;</span><br><span class="line">​<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line">​i = <span class="number">12</span>;</span><br><span class="line">​j = <span class="number">169</span>;</span><br><span class="line">​ <span class="keyword">do</span></span><br><span class="line">​ &#123;</span><br><span class="line">​<span class="keyword">while</span> (--j);</span><br><span class="line">​  &#125; <span class="keyword">while</span> (--i);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里的部分我们放到所以sbit下面，作为自定义函数。</p><p>如果在程序内需要引用，这样使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delay_ms(500);//将延时函数循环执行500次，即延时500ms</span><br></pre></td></tr></table></figure><p>于是，我们的主函数就变成了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;      init()</span><br><span class="line">       LSC=LSA=LSB;</span><br><span class="line">       L1= L2=L3=L4=L5=L6=L7=L8=<span class="number">1</span>;<span class="comment">//熄灭</span></span><br><span class="line">       delay_ms(<span class="number">500</span>)</span><br><span class="line">       L1= L2=L3=L4=L5=L6=L7=L8=<span class="number">0</span>;<span class="comment">//点亮</span></span><br><span class="line">       delay_ms(<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>每次都要把L1到L8都写一遍。是不是这样写太麻烦了？还有一个更简单的写法。</p><h2 id="把L1到L8对应的数字改写成16进制，"><a href="#把L1到L8对应的数字改写成16进制，" class="headerlink" title="把L1到L8对应的数字改写成16进制，"></a>把L1到L8对应的数字改写成16进制，</h2><p>主函数部分更改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">P0=0x00;</span><br><span class="line">delay_ms(500);</span><br><span class="line">P0=0xff;</span><br><span class="line">delay_ms(500);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外需要注意的一点是，每次LED的初始状态需要为<strong>熄灭状态</strong>。</p><p>所以我们这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void init()//init函数为初始化LED</span><br><span class="line">&#123;</span><br><span class="line">LSC=1;LSB =0;LSA=1;</span><br><span class="line">P0=0x00;//防止蜂鸣器和继电器乱响</span><br><span class="line">LSC=1;LSB=0;LSB=0;</span><br><span class="line">P0=0xff;//LED初始化为熄灭状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：我后续写程序的思路是模块化编程，每个功能尽量使用一个函数来实现。 </p><p>例如：刚刚写的LED程序，改成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void led()</span><br><span class="line">&#123;</span><br><span class="line">P0=0x00;</span><br><span class="line">delay_ms(500);</span><br><span class="line">P0=0xff;</span><br><span class="line">delay_ms(500);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们的主函数就变为了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    init();//初始化</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    led();//调用led函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>通过<strong>取反操作符</strong>，我们还能简化led的程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void led()</span><br><span class="line">&#123;</span><br><span class="line">P0 =~P0;</span><br><span class="line">delay_ms(500);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以这么做的原因的我们在init()中已经把P0全部熄灭了，在led的程序中我们使用取反操作符就刚好能把0x00全部取反为0xff,也就是把熄灭变为点亮。</p><h2 id="流水灯"><a href="#流水灯" class="headerlink" title="流水灯"></a>流水灯</h2><p>讲完上面最麻烦的方法，逐一定义每个灯可以实现，不过，我们有运算符，那么，我们流水灯的代码也就不复杂了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   void main()</span><br><span class="line">&#123;</span><br><span class="line">    init();//初始化</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">   P0 = P0 &lt;&lt; 1;//这里也可以更改为我们定义好的led函数，写法是一样的</span><br><span class="line">   delay_ms(500)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，程序的循环体每次执行一次，我们的P0的值就会从11111变为01111，00111，00011…..从而达到流水灯的效果。</p><p>PS：从左到右</p><h6 id="十分简洁。"><a href="#十分简洁。" class="headerlink" title="十分简洁。"></a>十分简洁。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;蓝桥杯&lt;/p&gt;
&lt;p&gt;一.LED以及锁存器的跟随模式，io模式vcc或非门，keil新建项目文件以及第一个程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/capture_20240228192033725.bmp&quot; alt=&quot;capture_202402281920337</summary>
      
    
    
    
    <category term="蓝桥杯" scheme="http://example.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>你好，佳佳</title>
    <link href="http://example.com/2024/02/07/cs2/"/>
    <id>http://example.com/2024/02/07/cs2/</id>
    <published>2024-02-07T11:39:43.000Z</published>
    <updated>2024-02-28T15:02:33.824Z</updated>
    
    <content type="html"><![CDATA[<p>昨天晚上，我做了一个梦。睡眠不好的时候我才会做梦。</p><p>可是，昨天的我回到家，明明那么累，却还是做了一个梦。</p><p>说它是梦都会显得它很长了。</p><p>我梦到，我抢到佳佳子的签售票了。</p><p>梦的全部，就只是我拿出手机，看见在“我的购票”那一栏，出现了我买到的佳佳的签售票。</p><p>就只是这么简单的一个动作，我还要做个梦。听起来很好笑对吧。我也觉得好笑。</p><p>小时候也会做这样的梦：想买一个很想要的玩具，可恶的爸妈就是不买。我哭哭啼啼地离开玩具店，回家躺在床上就会梦到我拥有了这个玩具。</p><p>在梦里，我把硬纸的背板从吸塑上扯下，玩具从吸塑里掉到床上，我拿着它和老伙计汇合，看看你的胳膊能不能给他装上，你的武器能不能借我用用。</p><p>我可从不管这些梦里的玩具是什么来路，也许是爸爸进城里给我的惊喜，亦或是爷爷许久未来看他孙子时候路上买的最贵的玩具。</p><p>总之，我喜欢梦里拥有玩具的感觉。这样的梦经历了几次之后，我就明白这是梦了。</p><p>后来，我还是会在梦里拥有我想要的玩具，即便我知道那是梦，我也会竭尽所能地不去醒来。但是，我还是发现了一件令我害怕的事。如果在梦里，我极力地把玩具的细节描绘清楚，我就会不可避免的醒来。并且这种行为和具有故事属性的梦境不同，没有故事发展的梦，是无法在醒来后迅速睡着衔接起来。</p><p>从这之后，不知道为什么，这样的梦就越来越少了。</p><p>也可以说，我的梦越来越少了。</p><p>但是我的白日梦却越来越多。</p><p>我会在写奥数作业的时候幻想，也许我这一次吃好多德克士的炸鸡之后脑子就会解开所有奥数题。</p><p>我会在阳光照到她头发上时幻想，也许今天结束晚自习后，她会把我拉到教室后面小声告诉我其实她也喜欢我。</p><p>我会在对完模考题的答案之后幻想，也行试卷上的答案是错的，碰巧我涂在答题卡上的才是正确答案。</p><p>我会在开学第一天分班的时候幻想，也许新班级的花名册上也有你的名字。也许你会和我分到一个小组。</p><p>我会在高考对完答案后幻想，也许这份答案有问题呢，也许高考批阅人那里的答案和我是一样的。</p><p>我会在填完志愿后幻想，也许这个学校会被我捡漏，也许我刚好是压着它的分数线被录取的。也许我录取到的学校刚好也录取了你。</p><p>我会在学那些晦涩的专业课的时候幻想，也许我是这个专业的天才呢，也许我稍微认真一点就能比肩那些在比赛里意气风发的学长。</p><p>我会在街上戴耳机信步的时候幻想，也许下一个街角我就会撞见要回家的你。</p><p>你看着我，好像有话要说<br>。<br>不过，我不会让你说的。</p><p>如果梦的细节太清楚，我迟早会醒来。</p><p>所以，我就当真的碰见了你。真的你也不知道我碰见了当真的你。</p><p>我这样想着，也就没那么难过了，反正我迟早会见到佳佳。不管是抖音里还是微博里，不管是现实里还是梦里。</p><p>然后我就高兴起来啦，因为我也迟早会再次见到你。也许是在别人的朋友圈，也许在是同学聚会 也许是在你的婚礼，也许是在照片里，也许在是回忆里，亦或是在我看不懂的梦里。</p><p>某个我不知道的地方，肯定有一堆人在评选全世界最能做梦的人。我想，我一定在候选人的名单里。</p><p>我正准备睡觉，突然这样幻想起来。</p><p>不过奇怪的是，我没有直接梦见佳佳，而是梦见了我有了她的签售票。就像我很少梦见你，却经常梦见你给我发来的消息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天晚上，我做了一个梦。睡眠不好的时候我才会做梦。&lt;/p&gt;
&lt;p&gt;可是，昨天的我回到家，明明那么累，却还是做了一个梦。&lt;/p&gt;
&lt;p&gt;说它是梦都会显得它很长了。&lt;/p&gt;
&lt;p&gt;我梦到，我抢到佳佳子的签售票了。&lt;/p&gt;
&lt;p&gt;梦的全部，就只是我拿出手机，看见在“我的购票”那一</summary>
      
    
    
    
    <category term="有话" scheme="http://example.com/categories/%E6%9C%89%E8%AF%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>故事很短，你随便看看</title>
    <link href="http://example.com/2023/08/13/cs1/"/>
    <id>http://example.com/2023/08/13/cs1/</id>
    <published>2023-08-13T15:39:22.000Z</published>
    <updated>2024-02-28T15:02:26.582Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个很短的故事。</p><p>想起三年前刚开学，有个特别特别好看的姑娘和我一个小组。<br>我们这里最小单位就是五人小组，没有同桌。<br>她特别单纯，还和我小学是一个辅导班。<br>她记得我，不过我并不记得她。<br>这开局直接就是天选。但是我一手好牌打得稀烂。<br>和那些稍微会一点小心思的男生比起来我就是弱鸡。<br>啥也不懂，啥也不明白，最后还被她感觉烦了。<br>暗自神伤地喜欢了她一年。<br>现在想起来我就是纯纯大舔狗，还是那种人家不要还硬凑的感觉。<br>高一结束就分班了。<br>看完分班结果真的就是天塌下来的感觉。<br>很遗憾没和她一个班。<br>她留在了普通班，我去了稍微好一点的班。<br>我想过她会和谁在一起，但是没人想过她，会和高一新来的小男生在一起。<br>这件事让全年级的人大跌眼镜。<br>没错，就是全年级。<br>毕竟她是年级的大美女，我们都以为最后她会和那种学习又好人也好的男生在一起。<br>我们都自己说，高一就高一吧，毕竟人如果不错的话我们也不会乱说话<br>不过在一起了两个月她们就分手了。<br>听闻高一的风言风语，这小男生嫖过。<br>这件事对于我们年级来说都大为震撼 毕竟我的高中还是相当不错的，没有那些社会学生。<br>后来我问她 你这什么眼光，她说 她应该没有嫖过，但恐怕或多或少肯定沾染过，毕竟没有空穴来风的事情。<br>后来小男生在宿舍聚众抽烟被停课三个月。<br>不过整个高二我的心神已经被搅乱了。<br>现在想想，那段时间我真的和傻了一样。还跑到楼下喊“刘xx,U are the apple of my eye!”</p><p>是一本书封面的句子，也是一部电影里出现过的画面。</p><p>那部电影和小说同名，叫《那些年，我们一起追的女孩》<br>所以结果显而易见，即便后来高三发奋，依然只能上个普通的一本学校。虽然也能去很多偏远的211，不过最后这毕竟不是好结果。<br>后来她依然很美，朋友圈依然不乏刷屏的评论，一如既往。</p><p>她现在也早就有了男朋友，是西电的。不是我这个西邮比得了的。</p><p>但我老是觉得她好像没以前好看了。<br>她仍然是美女，不过少了一点神韵。<br>一点我喜欢她的时候的神韵。<br>她最好的样子好像也一去不复返了。<br>可能吧，也许只有我这么想。<br>也许回不去的是曾经喜欢她的我呢。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一个很短的故事。&lt;/p&gt;
&lt;p&gt;想起三年前刚开学，有个特别特别好看的姑娘和我一个小组。&lt;br&gt;我们这里最小单位就是五人小组，没有同桌。&lt;br&gt;她特别单纯，还和我小学是一个辅导班。&lt;br&gt;她记得我，不过我并不记得她。&lt;br&gt;这开局直接就是天选。但是我一手好牌打得稀烂。&lt;b</summary>
      
    
    
    
    <category term="有话" scheme="http://example.com/categories/%E6%9C%89%E8%AF%9D/"/>
    
    
  </entry>
  
</feed>
